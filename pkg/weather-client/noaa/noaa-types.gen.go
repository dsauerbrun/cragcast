// Package noaatypes provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package noaatypes

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	UserAgentScopes = "userAgent.Scopes"
)

// Defines values for AlertCategory.
const (
	AlertCategoryCBRNE     AlertCategory = "CBRNE"
	AlertCategoryEnv       AlertCategory = "Env"
	AlertCategoryFire      AlertCategory = "Fire"
	AlertCategoryGeo       AlertCategory = "Geo"
	AlertCategoryHealth    AlertCategory = "Health"
	AlertCategoryInfra     AlertCategory = "Infra"
	AlertCategoryMet       AlertCategory = "Met"
	AlertCategoryOther     AlertCategory = "Other"
	AlertCategoryRescue    AlertCategory = "Rescue"
	AlertCategorySafety    AlertCategory = "Safety"
	AlertCategorySecurity  AlertCategory = "Security"
	AlertCategoryTransport AlertCategory = "Transport"
)

// Defines values for AlertResponse.
const (
	AllClear AlertResponse = "AllClear"
	Assess   AlertResponse = "Assess"
	Avoid    AlertResponse = "Avoid"
	Evacuate AlertResponse = "Evacuate"
	Execute  AlertResponse = "Execute"
	Monitor  AlertResponse = "Monitor"
	None     AlertResponse = "None"
	Prepare  AlertResponse = "Prepare"
	Shelter  AlertResponse = "Shelter"
)

// Defines values for AlertCertaintyEnum.
const (
	AlertCertaintyEnumLikely   AlertCertaintyEnum = "Likely"
	AlertCertaintyEnumObserved AlertCertaintyEnum = "Observed"
	AlertCertaintyEnumPossible AlertCertaintyEnum = "Possible"
	AlertCertaintyEnumUnknown  AlertCertaintyEnum = "Unknown"
	AlertCertaintyEnumUnlikely AlertCertaintyEnum = "Unlikely"
)

// Defines values for AlertCollectionGeoJsonType.
const (
	AlertCollectionGeoJsonTypeFeatureCollection AlertCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for AlertGeoJsonType.
const (
	AlertGeoJsonTypeFeature AlertGeoJsonType = "Feature"
)

// Defines values for AlertMessageTypeEnum.
const (
	AlertMessageTypeEnumAck    AlertMessageTypeEnum = "Ack"
	AlertMessageTypeEnumAlert  AlertMessageTypeEnum = "Alert"
	AlertMessageTypeEnumCancel AlertMessageTypeEnum = "Cancel"
	AlertMessageTypeEnumError  AlertMessageTypeEnum = "Error"
	AlertMessageTypeEnumUpdate AlertMessageTypeEnum = "Update"
)

// Defines values for AlertSeverityEnum.
const (
	AlertSeverityEnumExtreme  AlertSeverityEnum = "Extreme"
	AlertSeverityEnumMinor    AlertSeverityEnum = "Minor"
	AlertSeverityEnumModerate AlertSeverityEnum = "Moderate"
	AlertSeverityEnumSevere   AlertSeverityEnum = "Severe"
	AlertSeverityEnumUnknown  AlertSeverityEnum = "Unknown"
)

// Defines values for AlertStatusEnum.
const (
	AlertStatusEnumActual   AlertStatusEnum = "Actual"
	AlertStatusEnumDraft    AlertStatusEnum = "Draft"
	AlertStatusEnumExercise AlertStatusEnum = "Exercise"
	AlertStatusEnumSystem   AlertStatusEnum = "System"
	AlertStatusEnumTest     AlertStatusEnum = "Test"
)

// Defines values for AlertUrgencyEnum.
const (
	AlertUrgencyEnumExpected  AlertUrgencyEnum = "Expected"
	AlertUrgencyEnumFuture    AlertUrgencyEnum = "Future"
	AlertUrgencyEnumImmediate AlertUrgencyEnum = "Immediate"
	AlertUrgencyEnumPast      AlertUrgencyEnum = "Past"
	AlertUrgencyEnumUnknown   AlertUrgencyEnum = "Unknown"
)

// Defines values for CenterWeatherAdvisoryCollectionGeoJsonType.
const (
	CenterWeatherAdvisoryCollectionGeoJsonTypeFeatureCollection CenterWeatherAdvisoryCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for CenterWeatherAdvisoryGeoJsonType.
const (
	CenterWeatherAdvisoryGeoJsonTypeFeature CenterWeatherAdvisoryGeoJsonType = "Feature"
)

// Defines values for GeoJsonFeatureType.
const (
	GeoJsonFeatureTypeFeature GeoJsonFeatureType = "Feature"
)

// Defines values for GeoJsonFeatureCollectionType.
const (
	GeoJsonFeatureCollectionTypeFeatureCollection GeoJsonFeatureCollectionType = "FeatureCollection"
)

// Defines values for GridpointType.
const (
	WxGridpoint GridpointType = "wx:Gridpoint"
)

// Defines values for GridpointWeatherValuesValueAttributes.
const (
	DamagingWind     GridpointWeatherValuesValueAttributes = "damaging_wind"
	DryThunderstorms GridpointWeatherValuesValueAttributes = "dry_thunderstorms"
	Flooding         GridpointWeatherValuesValueAttributes = "flooding"
	GustyWind        GridpointWeatherValuesValueAttributes = "gusty_wind"
	HeavyRain        GridpointWeatherValuesValueAttributes = "heavy_rain"
	LargeHail        GridpointWeatherValuesValueAttributes = "large_hail"
	SmallHail        GridpointWeatherValuesValueAttributes = "small_hail"
	Tornadoes        GridpointWeatherValuesValueAttributes = "tornadoes"
)

// Defines values for GridpointWeatherValuesValueCoverage.
const (
	Areas        GridpointWeatherValuesValueCoverage = "areas"
	Brief        GridpointWeatherValuesValueCoverage = "brief"
	Chance       GridpointWeatherValuesValueCoverage = "chance"
	Definite     GridpointWeatherValuesValueCoverage = "definite"
	Few          GridpointWeatherValuesValueCoverage = "few"
	Frequent     GridpointWeatherValuesValueCoverage = "frequent"
	Intermittent GridpointWeatherValuesValueCoverage = "intermittent"
	Isolated     GridpointWeatherValuesValueCoverage = "isolated"
	Likely       GridpointWeatherValuesValueCoverage = "likely"
	Numerous     GridpointWeatherValuesValueCoverage = "numerous"
	Occasional   GridpointWeatherValuesValueCoverage = "occasional"
	Patchy       GridpointWeatherValuesValueCoverage = "patchy"
	Periods      GridpointWeatherValuesValueCoverage = "periods"
	Scattered    GridpointWeatherValuesValueCoverage = "scattered"
	SlightChance GridpointWeatherValuesValueCoverage = "slight_chance"
	Widespread   GridpointWeatherValuesValueCoverage = "widespread"
)

// Defines values for GridpointWeatherValuesValueIntensity.
const (
	GridpointWeatherValuesValueIntensityHeavy     GridpointWeatherValuesValueIntensity = "heavy"
	GridpointWeatherValuesValueIntensityLight     GridpointWeatherValuesValueIntensity = "light"
	GridpointWeatherValuesValueIntensityModerate  GridpointWeatherValuesValueIntensity = "moderate"
	GridpointWeatherValuesValueIntensityVeryLight GridpointWeatherValuesValueIntensity = "very_light"
)

// Defines values for GridpointWeatherValuesValueWeather.
const (
	BlowingDust     GridpointWeatherValuesValueWeather = "blowing_dust"
	BlowingSand     GridpointWeatherValuesValueWeather = "blowing_sand"
	BlowingSnow     GridpointWeatherValuesValueWeather = "blowing_snow"
	Drizzle         GridpointWeatherValuesValueWeather = "drizzle"
	Fog             GridpointWeatherValuesValueWeather = "fog"
	FreezingDrizzle GridpointWeatherValuesValueWeather = "freezing_drizzle"
	FreezingFog     GridpointWeatherValuesValueWeather = "freezing_fog"
	FreezingRain    GridpointWeatherValuesValueWeather = "freezing_rain"
	FreezingSpray   GridpointWeatherValuesValueWeather = "freezing_spray"
	Frost           GridpointWeatherValuesValueWeather = "frost"
	Hail            GridpointWeatherValuesValueWeather = "hail"
	Haze            GridpointWeatherValuesValueWeather = "haze"
	IceCrystals     GridpointWeatherValuesValueWeather = "ice_crystals"
	IceFog          GridpointWeatherValuesValueWeather = "ice_fog"
	Rain            GridpointWeatherValuesValueWeather = "rain"
	RainShowers     GridpointWeatherValuesValueWeather = "rain_showers"
	Sleet           GridpointWeatherValuesValueWeather = "sleet"
	Smoke           GridpointWeatherValuesValueWeather = "smoke"
	Snow            GridpointWeatherValuesValueWeather = "snow"
	SnowShowers     GridpointWeatherValuesValueWeather = "snow_showers"
	Thunderstorms   GridpointWeatherValuesValueWeather = "thunderstorms"
	VolcanicAsh     GridpointWeatherValuesValueWeather = "volcanic_ash"
	WaterSpouts     GridpointWeatherValuesValueWeather = "water_spouts"
)

// Defines values for GridpointForecastGeoJsonType.
const (
	GridpointForecastGeoJsonTypeFeature GridpointForecastGeoJsonType = "Feature"
)

// Defines values for GridpointForecastPeriodTemperatureTrend.
const (
	Falling GridpointForecastPeriodTemperatureTrend = "falling"
	Rising  GridpointForecastPeriodTemperatureTrend = "rising"
)

// Defines values for GridpointForecastPeriodTemperatureUnit.
const (
	GridpointForecastPeriodTemperatureUnitC GridpointForecastPeriodTemperatureUnit = "C"
	GridpointForecastPeriodTemperatureUnitF GridpointForecastPeriodTemperatureUnit = "F"
)

// Defines values for GridpointForecastPeriodWindDirection.
const (
	GridpointForecastPeriodWindDirectionE   GridpointForecastPeriodWindDirection = "E"
	GridpointForecastPeriodWindDirectionENE GridpointForecastPeriodWindDirection = "ENE"
	GridpointForecastPeriodWindDirectionESE GridpointForecastPeriodWindDirection = "ESE"
	GridpointForecastPeriodWindDirectionN   GridpointForecastPeriodWindDirection = "N"
	GridpointForecastPeriodWindDirectionNE  GridpointForecastPeriodWindDirection = "NE"
	GridpointForecastPeriodWindDirectionNNE GridpointForecastPeriodWindDirection = "NNE"
	GridpointForecastPeriodWindDirectionNNW GridpointForecastPeriodWindDirection = "NNW"
	GridpointForecastPeriodWindDirectionNW  GridpointForecastPeriodWindDirection = "NW"
	GridpointForecastPeriodWindDirectionS   GridpointForecastPeriodWindDirection = "S"
	GridpointForecastPeriodWindDirectionSE  GridpointForecastPeriodWindDirection = "SE"
	GridpointForecastPeriodWindDirectionSSE GridpointForecastPeriodWindDirection = "SSE"
	GridpointForecastPeriodWindDirectionSSW GridpointForecastPeriodWindDirection = "SSW"
	GridpointForecastPeriodWindDirectionSW  GridpointForecastPeriodWindDirection = "SW"
	GridpointForecastPeriodWindDirectionW   GridpointForecastPeriodWindDirection = "W"
	GridpointForecastPeriodWindDirectionWNW GridpointForecastPeriodWindDirection = "WNW"
	GridpointForecastPeriodWindDirectionWSW GridpointForecastPeriodWindDirection = "WSW"
)

// Defines values for GridpointForecastUnitsEnum.
const (
	Si GridpointForecastUnitsEnum = "si"
	Us GridpointForecastUnitsEnum = "us"
)

// Defines values for GridpointGeoJsonType.
const (
	GridpointGeoJsonTypeFeature GridpointGeoJsonType = "Feature"
)

// Defines values for LandRegionCode.
const (
	AR LandRegionCode = "AR"
	CR LandRegionCode = "CR"
	ER LandRegionCode = "ER"
	PR LandRegionCode = "PR"
	SR LandRegionCode = "SR"
	WR LandRegionCode = "WR"
)

// Defines values for MarineAreaCode.
const (
	MarineAreaCodeAM MarineAreaCode = "AM"
	MarineAreaCodeAN MarineAreaCode = "AN"
	MarineAreaCodeGM MarineAreaCode = "GM"
	MarineAreaCodeLC MarineAreaCode = "LC"
	MarineAreaCodeLE MarineAreaCode = "LE"
	MarineAreaCodeLH MarineAreaCode = "LH"
	MarineAreaCodeLM MarineAreaCode = "LM"
	MarineAreaCodeLO MarineAreaCode = "LO"
	MarineAreaCodeLS MarineAreaCode = "LS"
	MarineAreaCodePH MarineAreaCode = "PH"
	MarineAreaCodePK MarineAreaCode = "PK"
	MarineAreaCodePM MarineAreaCode = "PM"
	MarineAreaCodePS MarineAreaCode = "PS"
	MarineAreaCodePZ MarineAreaCode = "PZ"
	MarineAreaCodeSL MarineAreaCode = "SL"
)

// Defines values for MarineRegionCode.
const (
	MarineRegionCodeAL MarineRegionCode = "AL"
	MarineRegionCodeAT MarineRegionCode = "AT"
	MarineRegionCodeGL MarineRegionCode = "GL"
	MarineRegionCodeGM MarineRegionCode = "GM"
	MarineRegionCodePA MarineRegionCode = "PA"
	MarineRegionCodePI MarineRegionCode = "PI"
)

// Defines values for MetarPhenomenonIntensity.
const (
	MetarPhenomenonIntensityHeavy MetarPhenomenonIntensity = "heavy"
	MetarPhenomenonIntensityLight MetarPhenomenonIntensity = "light"
)

// Defines values for MetarPhenomenonModifier.
const (
	Blowing     MetarPhenomenonModifier = "blowing"
	Freezing    MetarPhenomenonModifier = "freezing"
	LowDrifting MetarPhenomenonModifier = "low_drifting"
	Partial     MetarPhenomenonModifier = "partial"
	Patches     MetarPhenomenonModifier = "patches"
	Shallow     MetarPhenomenonModifier = "shallow"
	Showers     MetarPhenomenonModifier = "showers"
)

// Defines values for MetarPhenomenonWeather.
const (
	MetarPhenomenonWeatherDrizzle       MetarPhenomenonWeather = "drizzle"
	MetarPhenomenonWeatherDust          MetarPhenomenonWeather = "dust"
	MetarPhenomenonWeatherDustStorm     MetarPhenomenonWeather = "dust_storm"
	MetarPhenomenonWeatherDustWhirls    MetarPhenomenonWeather = "dust_whirls"
	MetarPhenomenonWeatherFog           MetarPhenomenonWeather = "fog"
	MetarPhenomenonWeatherFogMist       MetarPhenomenonWeather = "fog_mist"
	MetarPhenomenonWeatherFunnelCloud   MetarPhenomenonWeather = "funnel_cloud"
	MetarPhenomenonWeatherHail          MetarPhenomenonWeather = "hail"
	MetarPhenomenonWeatherHaze          MetarPhenomenonWeather = "haze"
	MetarPhenomenonWeatherIceCrystals   MetarPhenomenonWeather = "ice_crystals"
	MetarPhenomenonWeatherIcePellets    MetarPhenomenonWeather = "ice_pellets"
	MetarPhenomenonWeatherRain          MetarPhenomenonWeather = "rain"
	MetarPhenomenonWeatherSand          MetarPhenomenonWeather = "sand"
	MetarPhenomenonWeatherSandStorm     MetarPhenomenonWeather = "sand_storm"
	MetarPhenomenonWeatherSmoke         MetarPhenomenonWeather = "smoke"
	MetarPhenomenonWeatherSnow          MetarPhenomenonWeather = "snow"
	MetarPhenomenonWeatherSnowGrains    MetarPhenomenonWeather = "snow_grains"
	MetarPhenomenonWeatherSnowPellets   MetarPhenomenonWeather = "snow_pellets"
	MetarPhenomenonWeatherSpray         MetarPhenomenonWeather = "spray"
	MetarPhenomenonWeatherSqualls       MetarPhenomenonWeather = "squalls"
	MetarPhenomenonWeatherThunderstorms MetarPhenomenonWeather = "thunderstorms"
	MetarPhenomenonWeatherUnknown       MetarPhenomenonWeather = "unknown"
	MetarPhenomenonWeatherVolcanicAsh   MetarPhenomenonWeather = "volcanic_ash"
)

// Defines values for MetarSkyCoverage.
const (
	BKN MetarSkyCoverage = "BKN"
	CLR MetarSkyCoverage = "CLR"
	FEW MetarSkyCoverage = "FEW"
	OVC MetarSkyCoverage = "OVC"
	SCT MetarSkyCoverage = "SCT"
	SKC MetarSkyCoverage = "SKC"
	VV  MetarSkyCoverage = "VV"
)

// Defines values for NWSCenterWeatherServiceUnitIdEnum.
const (
	ZAB NWSCenterWeatherServiceUnitIdEnum = "ZAB"
	ZAN NWSCenterWeatherServiceUnitIdEnum = "ZAN"
	ZAU NWSCenterWeatherServiceUnitIdEnum = "ZAU"
	ZBW NWSCenterWeatherServiceUnitIdEnum = "ZBW"
	ZDC NWSCenterWeatherServiceUnitIdEnum = "ZDC"
	ZDV NWSCenterWeatherServiceUnitIdEnum = "ZDV"
	ZFA NWSCenterWeatherServiceUnitIdEnum = "ZFA"
	ZFW NWSCenterWeatherServiceUnitIdEnum = "ZFW"
	ZHU NWSCenterWeatherServiceUnitIdEnum = "ZHU"
	ZID NWSCenterWeatherServiceUnitIdEnum = "ZID"
	ZJX NWSCenterWeatherServiceUnitIdEnum = "ZJX"
	ZKC NWSCenterWeatherServiceUnitIdEnum = "ZKC"
	ZLA NWSCenterWeatherServiceUnitIdEnum = "ZLA"
	ZLC NWSCenterWeatherServiceUnitIdEnum = "ZLC"
	ZMA NWSCenterWeatherServiceUnitIdEnum = "ZMA"
	ZME NWSCenterWeatherServiceUnitIdEnum = "ZME"
	ZMP NWSCenterWeatherServiceUnitIdEnum = "ZMP"
	ZNY NWSCenterWeatherServiceUnitIdEnum = "ZNY"
	ZOA NWSCenterWeatherServiceUnitIdEnum = "ZOA"
	ZOB NWSCenterWeatherServiceUnitIdEnum = "ZOB"
	ZSE NWSCenterWeatherServiceUnitIdEnum = "ZSE"
	ZTL NWSCenterWeatherServiceUnitIdEnum = "ZTL"
)

// Defines values for NWSForecastOfficeId.
const (
	ABQ NWSForecastOfficeId = "ABQ"
	ABR NWSForecastOfficeId = "ABR"
	AER NWSForecastOfficeId = "AER"
	AFC NWSForecastOfficeId = "AFC"
	AFG NWSForecastOfficeId = "AFG"
	AJK NWSForecastOfficeId = "AJK"
	AKQ NWSForecastOfficeId = "AKQ"
	ALU NWSForecastOfficeId = "ALU"
	ALY NWSForecastOfficeId = "ALY"
	AMA NWSForecastOfficeId = "AMA"
	APX NWSForecastOfficeId = "APX"
	ARX NWSForecastOfficeId = "ARX"
	BGM NWSForecastOfficeId = "BGM"
	BIS NWSForecastOfficeId = "BIS"
	BMX NWSForecastOfficeId = "BMX"
	BOI NWSForecastOfficeId = "BOI"
	BOU NWSForecastOfficeId = "BOU"
	BOX NWSForecastOfficeId = "BOX"
	BRO NWSForecastOfficeId = "BRO"
	BTV NWSForecastOfficeId = "BTV"
	BUF NWSForecastOfficeId = "BUF"
	BYZ NWSForecastOfficeId = "BYZ"
	CAE NWSForecastOfficeId = "CAE"
	CAR NWSForecastOfficeId = "CAR"
	CHS NWSForecastOfficeId = "CHS"
	CLE NWSForecastOfficeId = "CLE"
	CRP NWSForecastOfficeId = "CRP"
	CTP NWSForecastOfficeId = "CTP"
	CYS NWSForecastOfficeId = "CYS"
	DDC NWSForecastOfficeId = "DDC"
	DLH NWSForecastOfficeId = "DLH"
	DMX NWSForecastOfficeId = "DMX"
	DTX NWSForecastOfficeId = "DTX"
	DVN NWSForecastOfficeId = "DVN"
	EAX NWSForecastOfficeId = "EAX"
	EKA NWSForecastOfficeId = "EKA"
	EPZ NWSForecastOfficeId = "EPZ"
	EWX NWSForecastOfficeId = "EWX"
	FFC NWSForecastOfficeId = "FFC"
	FGF NWSForecastOfficeId = "FGF"
	FGZ NWSForecastOfficeId = "FGZ"
	FSD NWSForecastOfficeId = "FSD"
	FWD NWSForecastOfficeId = "FWD"
	GGW NWSForecastOfficeId = "GGW"
	GID NWSForecastOfficeId = "GID"
	GJT NWSForecastOfficeId = "GJT"
	GLD NWSForecastOfficeId = "GLD"
	GRB NWSForecastOfficeId = "GRB"
	GRR NWSForecastOfficeId = "GRR"
	GSP NWSForecastOfficeId = "GSP"
	GUM NWSForecastOfficeId = "GUM"
	GYX NWSForecastOfficeId = "GYX"
	HFO NWSForecastOfficeId = "HFO"
	HGX NWSForecastOfficeId = "HGX"
	HNX NWSForecastOfficeId = "HNX"
	HPA NWSForecastOfficeId = "HPA"
	HUN NWSForecastOfficeId = "HUN"
	ICT NWSForecastOfficeId = "ICT"
	ILM NWSForecastOfficeId = "ILM"
	ILN NWSForecastOfficeId = "ILN"
	ILX NWSForecastOfficeId = "ILX"
	IND NWSForecastOfficeId = "IND"
	IWX NWSForecastOfficeId = "IWX"
	JAN NWSForecastOfficeId = "JAN"
	JAX NWSForecastOfficeId = "JAX"
	JKL NWSForecastOfficeId = "JKL"
	KEY NWSForecastOfficeId = "KEY"
	LBF NWSForecastOfficeId = "LBF"
	LCH NWSForecastOfficeId = "LCH"
	LIX NWSForecastOfficeId = "LIX"
	LKN NWSForecastOfficeId = "LKN"
	LMK NWSForecastOfficeId = "LMK"
	LOT NWSForecastOfficeId = "LOT"
	LOX NWSForecastOfficeId = "LOX"
	LSX NWSForecastOfficeId = "LSX"
	LUB NWSForecastOfficeId = "LUB"
	LWX NWSForecastOfficeId = "LWX"
	LZK NWSForecastOfficeId = "LZK"
	MAF NWSForecastOfficeId = "MAF"
	MEG NWSForecastOfficeId = "MEG"
	MFL NWSForecastOfficeId = "MFL"
	MFR NWSForecastOfficeId = "MFR"
	MHX NWSForecastOfficeId = "MHX"
	MKX NWSForecastOfficeId = "MKX"
	MLB NWSForecastOfficeId = "MLB"
	MOB NWSForecastOfficeId = "MOB"
	MPX NWSForecastOfficeId = "MPX"
	MQT NWSForecastOfficeId = "MQT"
	MRX NWSForecastOfficeId = "MRX"
	MSO NWSForecastOfficeId = "MSO"
	MTR NWSForecastOfficeId = "MTR"
	NH1 NWSForecastOfficeId = "NH1"
	NH2 NWSForecastOfficeId = "NH2"
	OAX NWSForecastOfficeId = "OAX"
	OHX NWSForecastOfficeId = "OHX"
	OKX NWSForecastOfficeId = "OKX"
	ONA NWSForecastOfficeId = "ONA"
	ONP NWSForecastOfficeId = "ONP"
	OTX NWSForecastOfficeId = "OTX"
	OUN NWSForecastOfficeId = "OUN"
	PAH NWSForecastOfficeId = "PAH"
	PBZ NWSForecastOfficeId = "PBZ"
	PDT NWSForecastOfficeId = "PDT"
	PHI NWSForecastOfficeId = "PHI"
	PIH NWSForecastOfficeId = "PIH"
	PPG NWSForecastOfficeId = "PPG"
	PQR NWSForecastOfficeId = "PQR"
	PSR NWSForecastOfficeId = "PSR"
	PUB NWSForecastOfficeId = "PUB"
	RAH NWSForecastOfficeId = "RAH"
	REV NWSForecastOfficeId = "REV"
	RIW NWSForecastOfficeId = "RIW"
	RLX NWSForecastOfficeId = "RLX"
	RNK NWSForecastOfficeId = "RNK"
	SEW NWSForecastOfficeId = "SEW"
	SGF NWSForecastOfficeId = "SGF"
	SGX NWSForecastOfficeId = "SGX"
	SHV NWSForecastOfficeId = "SHV"
	SJT NWSForecastOfficeId = "SJT"
	SJU NWSForecastOfficeId = "SJU"
	SLC NWSForecastOfficeId = "SLC"
	STO NWSForecastOfficeId = "STO"
	STU NWSForecastOfficeId = "STU"
	TAE NWSForecastOfficeId = "TAE"
	TBW NWSForecastOfficeId = "TBW"
	TFX NWSForecastOfficeId = "TFX"
	TOP NWSForecastOfficeId = "TOP"
	TSA NWSForecastOfficeId = "TSA"
	TWC NWSForecastOfficeId = "TWC"
	UNR NWSForecastOfficeId = "UNR"
	VEF NWSForecastOfficeId = "VEF"
)

// Defines values for NWSNationalHQId.
const (
	NWS NWSNationalHQId = "NWS"
)

// Defines values for NWSRegionalHQId.
const (
	ARH NWSRegionalHQId = "ARH"
	CRH NWSRegionalHQId = "CRH"
	ERH NWSRegionalHQId = "ERH"
	PRH NWSRegionalHQId = "PRH"
	SRH NWSRegionalHQId = "SRH"
	WRH NWSRegionalHQId = "WRH"
)

// Defines values for NWSZoneType.
const (
	NWSZoneTypeCoastal  NWSZoneType = "coastal"
	NWSZoneTypeCounty   NWSZoneType = "county"
	NWSZoneTypeFire     NWSZoneType = "fire"
	NWSZoneTypeForecast NWSZoneType = "forecast"
	NWSZoneTypeLand     NWSZoneType = "land"
	NWSZoneTypeMarine   NWSZoneType = "marine"
	NWSZoneTypeOffshore NWSZoneType = "offshore"
	NWSZoneTypePublic   NWSZoneType = "public"
)

// Defines values for ObservationType.
const (
	ObservationTypeWxObservationStation ObservationType = "wx:ObservationStation"
)

// Defines values for ObservationCollectionGeoJsonType.
const (
	ObservationCollectionGeoJsonTypeFeatureCollection ObservationCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for ObservationGeoJsonType.
const (
	ObservationGeoJsonTypeFeature ObservationGeoJsonType = "Feature"
)

// Defines values for ObservationStationType.
const (
	ObservationStationTypeWxObservationStation ObservationStationType = "wx:ObservationStation"
)

// Defines values for ObservationStationCollectionGeoJsonType.
const (
	ObservationStationCollectionGeoJsonTypeFeatureCollection ObservationStationCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for ObservationStationGeoJsonType.
const (
	ObservationStationGeoJsonTypeFeature ObservationStationGeoJsonType = "Feature"
)

// Defines values for ObservationStationJsonLdType.
const (
	WxObservationStation ObservationStationJsonLdType = "wx:ObservationStation"
)

// Defines values for OfficeType.
const (
	GovernmentOrganization OfficeType = "GovernmentOrganization"
)

// Defines values for OfficeAddressType.
const (
	PostalAddress OfficeAddressType = "PostalAddress"
)

// Defines values for PointType.
const (
	PointTypeWxPoint PointType = "wx:Point"
)

// Defines values for PointGeoJsonType.
const (
	PointGeoJsonTypeFeature PointGeoJsonType = "Feature"
)

// Defines values for PointJsonLdType.
const (
	PointJsonLdTypeWxPoint PointJsonLdType = "wx:Point"
)

// Defines values for QuantitativeValueQualityControl.
const (
	QuantitativeValueQualityControlB QuantitativeValueQualityControl = "B"
	QuantitativeValueQualityControlC QuantitativeValueQualityControl = "C"
	QuantitativeValueQualityControlG QuantitativeValueQualityControl = "G"
	QuantitativeValueQualityControlQ QuantitativeValueQualityControl = "Q"
	QuantitativeValueQualityControlS QuantitativeValueQualityControl = "S"
	QuantitativeValueQualityControlT QuantitativeValueQualityControl = "T"
	QuantitativeValueQualityControlV QuantitativeValueQualityControl = "V"
	QuantitativeValueQualityControlX QuantitativeValueQualityControl = "X"
	QuantitativeValueQualityControlZ QuantitativeValueQualityControl = "Z"
)

// Defines values for RelativeLocationGeoJsonType.
const (
	RelativeLocationGeoJsonTypeFeature RelativeLocationGeoJsonType = "Feature"
)

// Defines values for SigmetCollectionGeoJsonType.
const (
	SigmetCollectionGeoJsonTypeFeatureCollection SigmetCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for SigmetGeoJsonType.
const (
	SigmetGeoJsonTypeFeature SigmetGeoJsonType = "Feature"
)

// Defines values for StateTerritoryCode.
const (
	StateTerritoryCodeAK StateTerritoryCode = "AK"
	StateTerritoryCodeAL StateTerritoryCode = "AL"
	StateTerritoryCodeAR StateTerritoryCode = "AR"
	StateTerritoryCodeAS StateTerritoryCode = "AS"
	StateTerritoryCodeAZ StateTerritoryCode = "AZ"
	StateTerritoryCodeCA StateTerritoryCode = "CA"
	StateTerritoryCodeCO StateTerritoryCode = "CO"
	StateTerritoryCodeCT StateTerritoryCode = "CT"
	StateTerritoryCodeDC StateTerritoryCode = "DC"
	StateTerritoryCodeDE StateTerritoryCode = "DE"
	StateTerritoryCodeFL StateTerritoryCode = "FL"
	StateTerritoryCodeFM StateTerritoryCode = "FM"
	StateTerritoryCodeGA StateTerritoryCode = "GA"
	StateTerritoryCodeGU StateTerritoryCode = "GU"
	StateTerritoryCodeHI StateTerritoryCode = "HI"
	StateTerritoryCodeIA StateTerritoryCode = "IA"
	StateTerritoryCodeID StateTerritoryCode = "ID"
	StateTerritoryCodeIL StateTerritoryCode = "IL"
	StateTerritoryCodeIN StateTerritoryCode = "IN"
	StateTerritoryCodeKS StateTerritoryCode = "KS"
	StateTerritoryCodeKY StateTerritoryCode = "KY"
	StateTerritoryCodeLA StateTerritoryCode = "LA"
	StateTerritoryCodeMA StateTerritoryCode = "MA"
	StateTerritoryCodeMD StateTerritoryCode = "MD"
	StateTerritoryCodeME StateTerritoryCode = "ME"
	StateTerritoryCodeMH StateTerritoryCode = "MH"
	StateTerritoryCodeMI StateTerritoryCode = "MI"
	StateTerritoryCodeMN StateTerritoryCode = "MN"
	StateTerritoryCodeMO StateTerritoryCode = "MO"
	StateTerritoryCodeMP StateTerritoryCode = "MP"
	StateTerritoryCodeMS StateTerritoryCode = "MS"
	StateTerritoryCodeMT StateTerritoryCode = "MT"
	StateTerritoryCodeNC StateTerritoryCode = "NC"
	StateTerritoryCodeND StateTerritoryCode = "ND"
	StateTerritoryCodeNE StateTerritoryCode = "NE"
	StateTerritoryCodeNH StateTerritoryCode = "NH"
	StateTerritoryCodeNJ StateTerritoryCode = "NJ"
	StateTerritoryCodeNM StateTerritoryCode = "NM"
	StateTerritoryCodeNV StateTerritoryCode = "NV"
	StateTerritoryCodeNY StateTerritoryCode = "NY"
	StateTerritoryCodeOH StateTerritoryCode = "OH"
	StateTerritoryCodeOK StateTerritoryCode = "OK"
	StateTerritoryCodeOR StateTerritoryCode = "OR"
	StateTerritoryCodePA StateTerritoryCode = "PA"
	StateTerritoryCodePR StateTerritoryCode = "PR"
	StateTerritoryCodePW StateTerritoryCode = "PW"
	StateTerritoryCodeRI StateTerritoryCode = "RI"
	StateTerritoryCodeSC StateTerritoryCode = "SC"
	StateTerritoryCodeSD StateTerritoryCode = "SD"
	StateTerritoryCodeTN StateTerritoryCode = "TN"
	StateTerritoryCodeTX StateTerritoryCode = "TX"
	StateTerritoryCodeUT StateTerritoryCode = "UT"
	StateTerritoryCodeVA StateTerritoryCode = "VA"
	StateTerritoryCodeVI StateTerritoryCode = "VI"
	StateTerritoryCodeVT StateTerritoryCode = "VT"
	StateTerritoryCodeWA StateTerritoryCode = "WA"
	StateTerritoryCodeWI StateTerritoryCode = "WI"
	StateTerritoryCodeWV StateTerritoryCode = "WV"
	StateTerritoryCodeWY StateTerritoryCode = "WY"
)

// Defines values for ZoneType.
const (
	WxZone ZoneType = "wx:Zone"
)

// Defines values for ZoneCollectionGeoJsonType.
const (
	FeatureCollection ZoneCollectionGeoJsonType = "FeatureCollection"
)

// Defines values for ZoneForecastGeoJsonType.
const (
	ZoneForecastGeoJsonTypeFeature ZoneForecastGeoJsonType = "Feature"
)

// Defines values for ZoneGeoJsonType.
const (
	ZoneGeoJsonTypeFeature ZoneGeoJsonType = "Feature"
)

// Defines values for AlertRegionType.
const (
	AlertRegionTypeLand   AlertRegionType = "land"
	AlertRegionTypeMarine AlertRegionType = "marine"
)

// Defines values for AlertsQueryParamsStatus.
const (
	AlertsQueryParamsStatusActual   AlertsQueryParamsStatus = "actual"
	AlertsQueryParamsStatusDraft    AlertsQueryParamsStatus = "draft"
	AlertsQueryParamsStatusExercise AlertsQueryParamsStatus = "exercise"
	AlertsQueryParamsStatusSystem   AlertsQueryParamsStatus = "system"
	AlertsQueryParamsStatusTest     AlertsQueryParamsStatus = "test"
)

// Defines values for AlertsQueryParamsMessageType.
const (
	AlertsQueryParamsMessageTypeAlert  AlertsQueryParamsMessageType = "alert"
	AlertsQueryParamsMessageTypeCancel AlertsQueryParamsMessageType = "cancel"
	AlertsQueryParamsMessageTypeUpdate AlertsQueryParamsMessageType = "update"
)

// Defines values for AlertsQueryParamsRegionType.
const (
	AlertsQueryParamsRegionTypeLand   AlertsQueryParamsRegionType = "land"
	AlertsQueryParamsRegionTypeMarine AlertsQueryParamsRegionType = "marine"
)

// Defines values for AlertsActiveParamsStatus.
const (
	Actual   AlertsActiveParamsStatus = "actual"
	Draft    AlertsActiveParamsStatus = "draft"
	Exercise AlertsActiveParamsStatus = "exercise"
	System   AlertsActiveParamsStatus = "system"
	Test     AlertsActiveParamsStatus = "test"
)

// Defines values for AlertsActiveParamsMessageType.
const (
	AlertsActiveParamsMessageTypeAlert  AlertsActiveParamsMessageType = "alert"
	AlertsActiveParamsMessageTypeCancel AlertsActiveParamsMessageType = "cancel"
	AlertsActiveParamsMessageTypeUpdate AlertsActiveParamsMessageType = "update"
)

// Defines values for AlertsActiveParamsRegionType.
const (
	Land   AlertsActiveParamsRegionType = "land"
	Marine AlertsActiveParamsRegionType = "marine"
)

// Defines values for GridpointForecastParamsFeatureFlags.
const (
	GridpointForecastParamsFeatureFlagsForecastTemperatureQv GridpointForecastParamsFeatureFlags = "forecast_temperature_qv"
	GridpointForecastParamsFeatureFlagsForecastWindSpeedQv   GridpointForecastParamsFeatureFlags = "forecast_wind_speed_qv"
)

// Defines values for GridpointForecastHourlyParamsFeatureFlags.
const (
	GridpointForecastHourlyParamsFeatureFlagsForecastTemperatureQv GridpointForecastHourlyParamsFeatureFlags = "forecast_temperature_qv"
	GridpointForecastHourlyParamsFeatureFlagsForecastWindSpeedQv   GridpointForecastHourlyParamsFeatureFlags = "forecast_wind_speed_qv"
)

// Defines values for Size0.
const (
	Large  Size0 = "large"
	Medium Size0 = "medium"
	Small  Size0 = "small"
)

// ATSUIdentifierString ATSU Identifier
type ATSUIdentifierString = string

// Alert An object representing a public alert message.
// Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information.
// http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://alerts.weather.gov/#technical-notes-v12
type Alert struct {
	// AffectedZones An array of API links for zones affected by the alert. This is an API-specific extension field and is not part of the CAP specification.
	AffectedZones *[]string `json:"affectedZones,omitempty"`

	// AreaDesc A textual description of the area affected by the alert.
	AreaDesc *string `json:"areaDesc,omitempty"`

	// Category The code denoting the category of the subject event of the alert message.
	Category           *AlertCategory      `json:"category,omitempty"`
	AlertCertaintyEnum *AlertCertaintyEnum `json:"certainty,omitempty"`

	// Description The text describing the subject event of the alert message.
	Description *string `json:"description,omitempty"`

	// Effective The effective time of the information of the alert message.
	Effective *time.Time `json:"effective,omitempty"`

	// Ends The expected end time of the subject event of the alert message.
	Ends *time.Time `json:"ends"`

	// Event The text denoting the type of the subject event of the alert message.
	Event *string `json:"event,omitempty"`

	// Expires The expiry time of the information of the alert message.
	Expires *time.Time `json:"expires,omitempty"`

	// Geocode Lists of codes for NWS public zones and counties affected by the alert.
	Geocode *struct {
		// SAME A list of SAME (Specific Area Message Encoding) codes for affected counties.
		SAME *[]string `json:"SAME,omitempty"`

		// UGC A list of NWS public zone or county identifiers.
		UGC *[]NWSZoneID `json:"UGC,omitempty"`
	} `json:"geocode,omitempty"`

	// Headline The text headline of the alert message.
	Headline *string `json:"headline"`

	// Id The identifier of the alert message.
	Id *AlertId `json:"id,omitempty"`

	// Instruction The text describing the recommended action to be taken by recipients of the alert message.
	Instruction          *string               `json:"instruction"`
	AlertMessageTypeEnum *AlertMessageTypeEnum `json:"messageType,omitempty"`

	// Onset The expected time of the beginning of the subject event of the alert message.
	Onset *time.Time `json:"onset"`

	// Parameters System-specific additional parameters associated with the alert message.
	// The keys in this object correspond to parameter definitions in the NWS CAP specification.
	Parameters *map[string][]interface{} `json:"parameters,omitempty"`

	// References A list of prior alerts that this alert updates or replaces.
	References *[]struct {
		// Id An API link to the prior alert.
		Id *string `json:"@id,omitempty"`

		// Identifier The identifier of the alert message.
		Identifier *AlertId `json:"identifier,omitempty"`

		// Sender The sender of the prior alert.
		Sender *string `json:"sender,omitempty"`

		// Sent The time the prior alert was sent.
		Sent *time.Time `json:"sent,omitempty"`
	} `json:"references,omitempty"`

	// Response The code denoting the type of action recommended for the target audience.
	// This corresponds to responseType in the CAP specification.
	Response *AlertResponse `json:"response,omitempty"`

	// Sender Email address of the NWS webmaster.
	Sender *string `json:"sender,omitempty"`

	// SenderName The text naming the originator of the alert message.
	SenderName *string `json:"senderName,omitempty"`

	// Sent The time of the origination of the alert message.
	Sent              *time.Time         `json:"sent,omitempty"`
	AlertSeverityEnum *AlertSeverityEnum `json:"severity,omitempty"`
	AlertStatusEnum   *AlertStatusEnum   `json:"status,omitempty"`
	AlertUrgencyEnum  *AlertUrgencyEnum  `json:"urgency,omitempty"`
}

// AlertCategory The code denoting the category of the subject event of the alert message.
type AlertCategory string

// AlertResponse The code denoting the type of action recommended for the target audience.
// This corresponds to responseType in the CAP specification.
type AlertResponse string

// AlertAtomEntry An alert entry in an Atom feed
type AlertAtomEntry struct {
	AreaDesc *string `json:"areaDesc,omitempty"`
	Author   *struct {
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`
	Category  *string              `json:"category,omitempty"`
	Certainty *string              `json:"certainty,omitempty"`
	Effective *string              `json:"effective,omitempty"`
	Event     *string              `json:"event,omitempty"`
	Expires   *string              `json:"expires,omitempty"`
	Geocode   *[]AlertXMLParameter `json:"geocode,omitempty"`
	Id        *string              `json:"id,omitempty"`
	MsgType   *string              `json:"msgType,omitempty"`
	Parameter *[]AlertXMLParameter `json:"parameter,omitempty"`
	Polygon   *string              `json:"polygon,omitempty"`
	Published *string              `json:"published,omitempty"`
	Sent      *string              `json:"sent,omitempty"`
	Severity  *string              `json:"severity,omitempty"`
	Status    *string              `json:"status,omitempty"`
	Summary   *string              `json:"summary,omitempty"`
	Updated   *string              `json:"updated,omitempty"`
	Urgency   *string              `json:"urgency,omitempty"`
}

// AlertAtomFeed An alert feed in Atom format
type AlertAtomFeed struct {
	Author *struct {
		Name *string `json:"name,omitempty"`
	} `json:"author,omitempty"`
	Entry     *[]AlertAtomEntry `json:"entry,omitempty"`
	Generator *string           `json:"generator,omitempty"`
	Id        *string           `json:"id,omitempty"`
	Title     *string           `json:"title,omitempty"`
	Updated   *string           `json:"updated,omitempty"`
}

// AlertCap defines model for AlertCap.
type AlertCap = map[string]interface{}

// AlertCertaintyEnum defines model for AlertCertainty.
type AlertCertaintyEnum string

// AlertCollection defines model for AlertCollection.
type AlertCollection struct {
	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`

	// Title A title describing the alert collection
	Title *string `json:"title,omitempty"`

	// Updated The last time a change occurred to this collection
	Updated *time.Time `json:"updated,omitempty"`
}

// AlertCollectionGeoJson defines model for AlertCollectionGeoJson.
type AlertCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		// Properties An object representing a public alert message.
		// Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information.
		// http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://alerts.weather.gov/#technical-notes-v12
		Properties *Alert `json:"properties,omitempty"`
	} `json:"features"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`

	// Title A title describing the alert collection
	Title *string                    `json:"title,omitempty"`
	Type  AlertCollectionGeoJsonType `json:"type"`

	// Updated The last time a change occurred to this collection
	Updated *time.Time `json:"updated,omitempty"`
}

// AlertCollectionGeoJsonType defines model for AlertCollectionGeoJson.Type.
type AlertCollectionGeoJsonType string

// AlertCollectionJsonLd defines model for AlertCollectionJsonLd.
type AlertCollectionJsonLd struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]Alert       `json:"@graph,omitempty"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`

	// Title A title describing the alert collection
	Title *string `json:"title,omitempty"`

	// Updated The last time a change occurred to this collection
	Updated *time.Time `json:"updated,omitempty"`
}

// AlertGeoJson defines model for AlertGeoJson.
type AlertGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties An object representing a public alert message.
	// Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information.
	// http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://alerts.weather.gov/#technical-notes-v12
	Properties Alert            `json:"properties"`
	Type       AlertGeoJsonType `json:"type"`
}

// AlertGeoJsonType defines model for AlertGeoJson.Type.
type AlertGeoJsonType string

// AlertId The identifier of the alert message.
type AlertId = string

// AlertJsonLd defines model for AlertJsonLd.
type AlertJsonLd struct {
	Graph *[]Alert `json:"@graph,omitempty"`
}

// AlertMessageTypeEnum defines model for AlertMessageType.
type AlertMessageTypeEnum string

// AlertSeverityEnum defines model for AlertSeverity.
type AlertSeverityEnum string

// AlertStatusEnum defines model for AlertStatus.
type AlertStatusEnum string

// AlertUrgencyEnum defines model for AlertUrgency.
type AlertUrgencyEnum string

// AlertXMLParameter defines model for AlertXMLParameter.
type AlertXMLParameter struct {
	Value     *string `json:"value,omitempty"`
	ValueName *string `json:"valueName,omitempty"`
}

// AreaCode State/territory codes and marine area codes
type AreaCode struct {
	union json.RawMessage
}

// BinaryFile defines model for BinaryFile.
type BinaryFile = openapi_types.File

// CenterWeatherAdvisory defines model for CenterWeatherAdvisory.
type CenterWeatherAdvisory struct {
	// Cwsu Three-letter identifier for a Center Weather Service Unit (CWSU).
	NWSCenterWeatherServiceUnitIdEnum *NWSCenterWeatherServiceUnitIdEnum `json:"cwsu,omitempty"`
	End                               *time.Time                         `json:"end,omitempty"`
	Id                                *string                            `json:"id,omitempty"`
	IssueTime                         *time.Time                         `json:"issueTime,omitempty"`
	ObservedProperty                  *string                            `json:"observedProperty,omitempty"`
	Sequence                          *int                               `json:"sequence,omitempty"`
	Start                             *time.Time                         `json:"start,omitempty"`
	Text                              *string                            `json:"text,omitempty"`
}

// CenterWeatherAdvisoryCollectionGeoJson defines model for CenterWeatherAdvisoryCollectionGeoJson.
type CenterWeatherAdvisoryCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *CenterWeatherAdvisory `json:"properties,omitempty"`
	} `json:"features"`
	Type CenterWeatherAdvisoryCollectionGeoJsonType `json:"type"`
}

// CenterWeatherAdvisoryCollectionGeoJsonType defines model for CenterWeatherAdvisoryCollectionGeoJson.Type.
type CenterWeatherAdvisoryCollectionGeoJsonType string

// CenterWeatherAdvisoryGeoJson defines model for CenterWeatherAdvisoryGeoJson.
type CenterWeatherAdvisoryGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry                 `json:"geometry"`
	Id         *string                          `json:"id,omitempty"`
	Properties CenterWeatherAdvisory            `json:"properties"`
	Type       CenterWeatherAdvisoryGeoJsonType `json:"type"`
}

// CenterWeatherAdvisoryGeoJsonType defines model for CenterWeatherAdvisoryGeoJson.Type.
type CenterWeatherAdvisoryGeoJsonType string

// CenterWeatherServiceUnitJsonLd defines model for CenterWeatherServiceUnitJsonLd.
type CenterWeatherServiceUnitJsonLd = Office

// DateString Date (in YYYY-MM-DD format).
type DateString = openapi_types.Date

// GeoJsonBoundingBox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonBoundingBox = []float32

// GeoJsonCoordinate A GeoJSON coordinate. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonCoordinate = []float32

// GeoJsonFeature A GeoJSON feature. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonFeature struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry       `json:"geometry"`
	Id         *string                `json:"id,omitempty"`
	Properties map[string]interface{} `json:"properties"`
	Type       GeoJsonFeatureType     `json:"type"`
}

// GeoJsonFeatureType defines model for GeoJsonFeature.Type.
type GeoJsonFeatureType string

// GeoJsonFeatureCollection A GeoJSON feature collection. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonFeatureCollection struct {
	Context  *JsonLdContext               `json:"@context,omitempty"`
	Features []GeoJsonFeature             `json:"features"`
	Type     GeoJsonFeatureCollectionType `json:"type"`
}

// GeoJsonFeatureCollectionType defines model for GeoJsonFeatureCollection.Type.
type GeoJsonFeatureCollectionType string

// GeoJsonGeometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonGeometry struct {
	union json.RawMessage
}

type GeoJsonGeometryType string

// GeoJsonGeometry0 defines model for .
type GeoJsonGeometry0 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox *GeoJsonBoundingBox `json:"bbox,omitempty"`

	// Coordinates A GeoJSON coordinate. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Coordinates GeoJsonCoordinate   `json:"coordinates"`
	Type        GeoJsonGeometryType `json:"type"`
}

// GeoJsonGeometry1 defines model for .
type GeoJsonGeometry1 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox *GeoJsonBoundingBox `json:"bbox,omitempty"`

	// Coordinates A GeoJSON line string. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Coordinates GeoJsonLineString   `json:"coordinates"`
	Type        GeoJsonGeometryType `json:"type"`
}

// GeoJsonGeometry2 defines model for .
type GeoJsonGeometry2 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox *GeoJsonBoundingBox `json:"bbox,omitempty"`

	// Coordinates A GeoJSON polygon. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Coordinates GeoJsonPolygon      `json:"coordinates"`
	Type        GeoJsonGeometryType `json:"type"`
}

// GeoJsonGeometry3 defines model for .
type GeoJsonGeometry3 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox        *GeoJsonBoundingBox `json:"bbox,omitempty"`
	Coordinates []GeoJsonCoordinate `json:"coordinates"`
	Type        GeoJsonGeometryType `json:"type"`
}

// GeoJsonGeometry4 defines model for .
type GeoJsonGeometry4 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox        *GeoJsonBoundingBox `json:"bbox,omitempty"`
	Coordinates []GeoJsonLineString `json:"coordinates"`
	Type        GeoJsonGeometryType `json:"type"`
}

// GeoJsonGeometry5 defines model for .
type GeoJsonGeometry5 struct {
	// Bbox A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Bbox        *GeoJsonBoundingBox `json:"bbox,omitempty"`
	Coordinates []GeoJsonPolygon    `json:"coordinates"`
	Type        GeoJsonGeometryType `json:"type"`
}

// GeoJsonLineString A GeoJSON line string. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonLineString = []GeoJsonCoordinate

// GeoJsonPolygon A GeoJSON polygon. Please refer to IETF RFC 7946 for information on the GeoJSON format.
type GeoJsonPolygon = [][]GeoJsonCoordinate

// GeometryString A geometry represented in Well-Known Text (WKT) format.
type GeometryString = string

// Gridpoint Raw forecast data for a 2.5km grid square.
// This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
// * temperature
// * dewpoint
// * maxTemperature
// * minTemperature
// * relativeHumidity
// * apparentTemperature
// * heatIndex
// * windChill
// * wetBulbGlobeTemperature
// * skyCover
// * windDirection
// * windSpeed
// * windGust
// * weather
// * hazards: Watch and advisory products in effect
// * probabilityOfPrecipitation
// * quantitativePrecipitation
// * iceAccumulation
// * snowfallAmount
// * snowLevel
// * ceilingHeight
// * visibility
// * transportWindSpeed
// * transportWindDirection
// * mixingHeight
// * hainesIndex
// * lightningActivityLevel
// * twentyFootWindSpeed
// * twentyFootWindDirection
// * waveHeight
// * wavePeriod
// * waveDirection
// * primarySwellHeight
// * primarySwellDirection
// * secondarySwellHeight
// * secondarySwellDirection
// * wavePeriod2
// * windWaveHeight
// * dispersionIndex
// * pressure: Barometric pressure
// * probabilityOfTropicalStormWinds
// * probabilityOfHurricaneWinds
// * potentialOf15mphWinds
// * potentialOf25mphWinds
// * potentialOf35mphWinds
// * potentialOf45mphWinds
// * potentialOf20mphWindGusts
// * potentialOf30mphWindGusts
// * potentialOf40mphWindGusts
// * potentialOf50mphWindGusts
// * potentialOf60mphWindGusts
// * grasslandFireDangerIndex
// * probabilityOfThunder
// * davisStabilityIndex
// * atmosphericDispersionIndex
// * lowVisibilityOccurrenceRiskIndex
// * stability
// * redFlagThreatIndex
type Gridpoint struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Id      *string        `json:"@id,omitempty"`
	Type    *GridpointType `json:"@type,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation      *QuantitativeValue `json:"elevation,omitempty"`
	ForecastOffice *string            `json:"forecastOffice,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`
	GridId   *string         `json:"gridId,omitempty"`
	GridX    *string            `json:"gridX,omitempty"`
	GridY    *string            `json:"gridY,omitempty"`
	Hazards  *struct {
		Values []struct {
			// ValidTime A time interval in ISO 8601 format. This can be one of:
			//
			//     1. Start and end time
			//     2. Start time and duration
			//     3. Duration and end time
			// The string "NOW" can also be used in place of a start/end time.
			ValidTime ISO8601Interval `json:"validTime"`
			Value     []struct {
				// EventNumber Event number. If this hazard refers to a national or regional center product (such as a Storm Prediction Center convective watch), this value will be the sequence number of that product.
				EventNumber *int `json:"event_number"`

				// Phenomenon Hazard code. This value will correspond to a P-VTEC phenomenon code as defined in NWS Directive 10-1703.
				Phenomenon string `json:"phenomenon"`

				// Significance Significance code. This value will correspond to a P-VTEC significance code as defined in NWS Directive 10-1703.
				// This will most frequently be "A" for a watch or "Y" for an advisory.
				Significance string `json:"significance"`
			} `json:"value"`
		} `json:"values"`
	} `json:"hazards,omitempty"`
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
	Weather    *struct {
		Values []struct {
			// ValidTime A time interval in ISO 8601 format. This can be one of:
			//
			//     1. Start and end time
			//     2. Start time and duration
			//     3. Duration and end time
			// The string "NOW" can also be used in place of a start/end time.
			ValidTime ISO8601Interval `json:"validTime"`
			Value     []struct {
				Attributes []GridpointWeatherValuesValueAttributes `json:"attributes"`
				Coverage   *GridpointWeatherValuesValueCoverage    `json:"coverage"`
				Intensity  *GridpointWeatherValuesValueIntensity   `json:"intensity"`

				// Visibility A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
				Visibility QuantitativeValue                   `json:"visibility"`
				Weather    *GridpointWeatherValuesValueWeather `json:"weather"`
			} `json:"value"`
		} `json:"values"`
	} `json:"weather,omitempty"`
	AdditionalProperties map[string]GridpointQuantitativeValueLayer `json:"-"`
}

// GridpointType defines model for Gridpoint.Type.
type GridpointType string

// GridpointWeatherValuesValueAttributes defines model for Gridpoint.Weather.Values.Value.Attributes.
type GridpointWeatherValuesValueAttributes string

// GridpointWeatherValuesValueCoverage defines model for Gridpoint.Weather.Values.Value.Coverage.
type GridpointWeatherValuesValueCoverage string

// GridpointWeatherValuesValueIntensity defines model for Gridpoint.Weather.Values.Value.Intensity.
type GridpointWeatherValuesValueIntensity string

// GridpointWeatherValuesValueWeather defines model for Gridpoint.Weather.Values.Value.Weather.
type GridpointWeatherValuesValueWeather string

// GridpointForecast A multi-day forecast for a 2.5km grid square.
type GridpointForecast struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// ForecastGenerator The internal generator class used to create the forecast text (used for NWS debugging).
	ForecastGenerator *string `json:"forecastGenerator,omitempty"`

	// GeneratedAt The time this forecast data was generated.
	GeneratedAt *time.Time `json:"generatedAt,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]GridpointForecastPeriod `json:"periods,omitempty"`

	// Units Denotes the units used in the textual portions of the forecast.
	GridpointForecastUnitsEnum *GridpointForecastUnitsEnum `json:"units,omitempty"`

	// UpdateTime The last update time of the data this forecast was generated from.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// Updated This property is deprecated (use updateTime instead).
	Updated *time.Time `json:"updated,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
}

// GridpointForecastGeoJson defines model for GridpointForecastGeoJson.
type GridpointForecastGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties A multi-day forecast for a 2.5km grid square.
	Properties GridpointForecast            `json:"properties"`
	Type       GridpointForecastGeoJsonType `json:"type"`
}

// GridpointForecastGeoJsonType defines model for GridpointForecastGeoJson.Type.
type GridpointForecastGeoJsonType string

// GridpointForecastJsonLd defines model for GridpointForecastJsonLd.
type GridpointForecastJsonLd struct {
	Context JsonLdContext `json:"@context"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// ForecastGenerator The internal generator class used to create the forecast text (used for NWS debugging).
	ForecastGenerator *string `json:"forecastGenerator,omitempty"`

	// GeneratedAt The time this forecast data was generated.
	GeneratedAt *time.Time `json:"generatedAt,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]GridpointForecastPeriod `json:"periods,omitempty"`

	// Units Denotes the units used in the textual portions of the forecast.
	GridpointForecastUnitsEnum *GridpointForecastUnitsEnum `json:"units,omitempty"`

	// UpdateTime The last update time of the data this forecast was generated from.
	UpdateTime *time.Time `json:"updateTime,omitempty"`

	// Updated This property is deprecated (use updateTime instead).
	Updated *time.Time `json:"updated,omitempty"`

	// ValidTimes A time interval in ISO 8601 format. This can be one of:
	//
	//     1. Start and end time
	//     2. Start time and duration
	//     3. Duration and end time
	// The string "NOW" can also be used in place of a start/end time.
	ValidTimes *ISO8601Interval `json:"validTimes,omitempty"`
}

// GridpointForecastPeriod An object containing forecast information for a specific time period (generally 12-hour or 1-hour).
type GridpointForecastPeriod struct {
	// DetailedForecast A detailed textual forecast for the period.
	DetailedForecast *string `json:"detailedForecast,omitempty"`

	// Dewpoint A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Dewpoint *QuantitativeValue `json:"dewpoint,omitempty"`

	// EndTime The ending time that this forecast period is valid for.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Icon A link to an icon representing the forecast summary.
	Icon *string `json:"icon,omitempty"`

	// IsDaytime Indicates whether this period is daytime or nighttime.
	IsDaytime *bool `json:"isDaytime,omitempty"`

	// Name A textual identifier for the period. This value will not be present for hourly forecasts.
	Name *string `json:"name,omitempty"`

	// Number Sequential period number.
	Number *int `json:"number,omitempty"`

	// ProbabilityOfPrecipitation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	ProbabilityOfPrecipitation *QuantitativeValue `json:"probabilityOfPrecipitation,omitempty"`

	// RelativeHumidity A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	RelativeHumidity *QuantitativeValue `json:"relativeHumidity,omitempty"`

	// ShortForecast A brief textual forecast summary for the period.
	ShortForecast *string `json:"shortForecast,omitempty"`

	// StartTime The starting time that this forecast period is valid for.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Temperature High/low temperature for the period, depending on whether the period is day or night.
	// This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
	Temperature *GridpointForecastPeriod_Temperature `json:"temperature,omitempty"`

	// TemperatureTrend If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
	TemperatureTrend *GridpointForecastPeriodTemperatureTrend `json:"temperatureTrend"`

	// TemperatureUnit The unit of the temperature value (Fahrenheit or Celsius).
	// This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
	TemperatureUnit *GridpointForecastPeriodTemperatureUnit `json:"temperatureUnit,omitempty"`

	// WindDirection The prevailing direction of the wind for the period, using a 16-point compass.
	WindDirection *GridpointForecastPeriodWindDirection `json:"windDirection,omitempty"`

	// WindGust Peak wind gust for the period.
	// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
	WindGust *GridpointForecastPeriod_WindGust `json:"windGust"`

	// WindSpeed Wind speed for the period.
	// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
	WindSpeed *GridpointForecastPeriod_WindSpeed `json:"windSpeed,omitempty"`
}

// GridpointForecastPeriodTemperature1 defines model for .
type GridpointForecastPeriodTemperature1 = int

// GridpointForecastPeriod_Temperature High/low temperature for the period, depending on whether the period is day or night.
// This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
type GridpointForecastPeriod_Temperature struct {
	union json.RawMessage
}

// GridpointForecastPeriodTemperatureTrend If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
type GridpointForecastPeriodTemperatureTrend string

// GridpointForecastPeriodTemperatureUnit The unit of the temperature value (Fahrenheit or Celsius).
// This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the "forecast_temperature_qv" feature flag on the request.
type GridpointForecastPeriodTemperatureUnit string

// GridpointForecastPeriodWindDirection The prevailing direction of the wind for the period, using a 16-point compass.
type GridpointForecastPeriodWindDirection string

// GridpointForecastPeriodWindGust1 defines model for .
type GridpointForecastPeriodWindGust1 = string

// GridpointForecastPeriod_WindGust Peak wind gust for the period.
// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
type GridpointForecastPeriod_WindGust struct {
	union json.RawMessage
}

// GridpointForecastPeriodWindSpeed1 defines model for .
type GridpointForecastPeriodWindSpeed1 = string

// GridpointForecastPeriod_WindSpeed Wind speed for the period.
// This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the "forecast_wind_speed_qv" feature flag on the request.
type GridpointForecastPeriod_WindSpeed struct {
	union json.RawMessage
}

// GridpointForecastUnitsEnum Denotes the units used in the textual portions of the forecast.
type GridpointForecastUnitsEnum string

// GridpointGeoJson defines model for GridpointGeoJson.
type GridpointGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties Raw forecast data for a 2.5km grid square.
	// This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
	// * temperature
	// * dewpoint
	// * maxTemperature
	// * minTemperature
	// * relativeHumidity
	// * apparentTemperature
	// * heatIndex
	// * windChill
	// * wetBulbGlobeTemperature
	// * skyCover
	// * windDirection
	// * windSpeed
	// * windGust
	// * weather
	// * hazards: Watch and advisory products in effect
	// * probabilityOfPrecipitation
	// * quantitativePrecipitation
	// * iceAccumulation
	// * snowfallAmount
	// * snowLevel
	// * ceilingHeight
	// * visibility
	// * transportWindSpeed
	// * transportWindDirection
	// * mixingHeight
	// * hainesIndex
	// * lightningActivityLevel
	// * twentyFootWindSpeed
	// * twentyFootWindDirection
	// * waveHeight
	// * wavePeriod
	// * waveDirection
	// * primarySwellHeight
	// * primarySwellDirection
	// * secondarySwellHeight
	// * secondarySwellDirection
	// * wavePeriod2
	// * windWaveHeight
	// * dispersionIndex
	// * pressure: Barometric pressure
	// * probabilityOfTropicalStormWinds
	// * probabilityOfHurricaneWinds
	// * potentialOf15mphWinds
	// * potentialOf25mphWinds
	// * potentialOf35mphWinds
	// * potentialOf45mphWinds
	// * potentialOf20mphWindGusts
	// * potentialOf30mphWindGusts
	// * potentialOf40mphWindGusts
	// * potentialOf50mphWindGusts
	// * potentialOf60mphWindGusts
	// * grasslandFireDangerIndex
	// * probabilityOfThunder
	// * davisStabilityIndex
	// * atmosphericDispersionIndex
	// * lowVisibilityOccurrenceRiskIndex
	// * stability
	// * redFlagThreatIndex
	Properties Gridpoint            `json:"properties"`
	Type       GridpointGeoJsonType `json:"type"`
}

// GridpointGeoJsonType defines model for GridpointGeoJson.Type.
type GridpointGeoJsonType string

// GridpointJsonLd Raw forecast data for a 2.5km grid square.
// This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
// * temperature
// * dewpoint
// * maxTemperature
// * minTemperature
// * relativeHumidity
// * apparentTemperature
// * heatIndex
// * windChill
// * wetBulbGlobeTemperature
// * skyCover
// * windDirection
// * windSpeed
// * windGust
// * weather
// * hazards: Watch and advisory products in effect
// * probabilityOfPrecipitation
// * quantitativePrecipitation
// * iceAccumulation
// * snowfallAmount
// * snowLevel
// * ceilingHeight
// * visibility
// * transportWindSpeed
// * transportWindDirection
// * mixingHeight
// * hainesIndex
// * lightningActivityLevel
// * twentyFootWindSpeed
// * twentyFootWindDirection
// * waveHeight
// * wavePeriod
// * waveDirection
// * primarySwellHeight
// * primarySwellDirection
// * secondarySwellHeight
// * secondarySwellDirection
// * wavePeriod2
// * windWaveHeight
// * dispersionIndex
// * pressure: Barometric pressure
// * probabilityOfTropicalStormWinds
// * probabilityOfHurricaneWinds
// * potentialOf15mphWinds
// * potentialOf25mphWinds
// * potentialOf35mphWinds
// * potentialOf45mphWinds
// * potentialOf20mphWindGusts
// * potentialOf30mphWindGusts
// * potentialOf40mphWindGusts
// * potentialOf50mphWindGusts
// * potentialOf60mphWindGusts
// * grasslandFireDangerIndex
// * probabilityOfThunder
// * davisStabilityIndex
// * atmosphericDispersionIndex
// * lowVisibilityOccurrenceRiskIndex
// * stability
// * redFlagThreatIndex
type GridpointJsonLd = Gridpoint

// GridpointQuantitativeValueLayer A gridpoint layer consisting of quantitative values (numeric values with associated units of measure).
type GridpointQuantitativeValueLayer struct {
	// Uom A string denoting a unit of measure, expressed in the format "{unit}" or "{namespace}:{unit}".
	// Units with the namespace "wmo" or "wmoUnit" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}.
	// Units with the namespace "nwsUnit" are currently custom and do not align to any standard.
	// Units with no namespace or the namespace "uc" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156).
	// Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
	Uom    *UnitOfMeasure `json:"uom,omitempty"`
	Values []struct {
		// ValidTime A time interval in ISO 8601 format. This can be one of:
		//
		//     1. Start and end time
		//     2. Start time and duration
		//     3. Duration and end time
		// The string "NOW" can also be used in place of a start/end time.
		ValidTime ISO8601Interval `json:"validTime"`
		Value     *float32        `json:"value"`
	} `json:"values"`
}

// ISO8601Duration A time duration in ISO 8601 format.
type ISO8601Duration = string

// ISO8601Interval A time interval in ISO 8601 format. This can be one of:
//
//     1. Start and end time
//     2. Start time and duration
//     3. Duration and end time
// The string "NOW" can also be used in place of a start/end time.
type ISO8601Interval struct {
	union json.RawMessage
}

// ISO8601Interval0 defines model for .
type ISO8601Interval0 = string

// ISO8601Interval1 defines model for .
type ISO8601Interval1 = string

// ISO8601Interval2 defines model for .
type ISO8601Interval2 = string

// JsonLdContext defines model for JsonLdContext.
type JsonLdContext struct {
	union json.RawMessage
}

// JsonLdContext0 defines model for .
type JsonLdContext0 = []interface{}

// JsonLdContext1 defines model for .
type JsonLdContext1 = map[string]interface{}

// LandRegionCode Land region code. These correspond to the six NWS regional headquarters:
// * AR: Alaska Region
// * CR: Central Region
// * ER: Eastern Region
// * PR: Pacific Region
// * SR: Southern Region
// * WR: Western Region
type LandRegionCode string

// MarineAreaCode Marine area code as defined in NWS Directive 10-302:
// * AM: Western North Atlantic Ocean and along U.S. East Coast south of Currituck Beach Light NC following the coastline into Gulf of Mexico to Ocean Reef FL including the Caribbean
// * AN: Western North Atlantic Ocean and along U.S. East Coast from Canadian border south to Currituck Beach Light NC
// * GM: Gulf of Mexico and along the U.S. Gulf Coast from the Mexican border to Ocean Reef FL
// * LC: Lake St. Clair
// * LE: Lake Erie
// * LH: Lake Huron
// * LM: Lake Michigan
// * LO: Lake Ontario
// * LS: Lake Superior
// * PH: Central Pacific Ocean including Hawaiian waters
// * PK: North Pacific Ocean near Alaska and along Alaska coastline including the Bering Sea and the Gulf of Alaska
// * PM: Western Pacific Ocean including Mariana Island waters
// * PS: South Central Pacific Ocean including American Samoa waters
// * PZ: Eastern North Pacific Ocean and along U.S. West Coast from Canadian border to Mexican border
// * SL: St. Lawrence River above St. Regis
type MarineAreaCode string

// MarineRegionCode Marine region code. These are groups of marine areas combined.
// * AL: Alaska waters (PK)
// * AT: Atlantic Ocean (AM, AN)
// * GL: Great Lakes (LC, LE, LH, LM, LO, LS, SL)
// * GM: Gulf of Mexico (GM)
// * PA: Eastern Pacific Ocean and U.S. West Coast (PZ)
// * PI: Central and Western Pacific (PH, PM, PS)
type MarineRegionCode string

// MetarPhenomenon An object representing a decoded METAR phenomenon string.
type MetarPhenomenon struct {
	InVicinity *bool                     `json:"inVicinity,omitempty"`
	Intensity  *MetarPhenomenonIntensity `json:"intensity"`
	Modifier   *MetarPhenomenonModifier  `json:"modifier"`
	RawString  string                    `json:"rawString"`
	Weather    MetarPhenomenonWeather    `json:"weather"`
}

// MetarPhenomenonIntensity defines model for MetarPhenomenon.Intensity.
type MetarPhenomenonIntensity string

// MetarPhenomenonModifier defines model for MetarPhenomenon.Modifier.
type MetarPhenomenonModifier string

// MetarPhenomenonWeather defines model for MetarPhenomenon.Weather.
type MetarPhenomenonWeather string

// MetarSkyCoverage defines model for MetarSkyCoverage.
type MetarSkyCoverage string

// NWSCenterWeatherServiceUnitIdEnum Three-letter identifier for a Center Weather Service Unit (CWSU).
type NWSCenterWeatherServiceUnitIdEnum string

// NWSForecastOfficeId Three-letter identifier for a NWS office.
type NWSForecastOfficeId string

// NWSNationalHQId Three-letter identifier for NWS National HQ.
type NWSNationalHQId string

// NWSOfficeId defines model for NWSOfficeId.
type NWSOfficeId struct {
	union json.RawMessage
}

// NWSRegionalHQId Three-letter identifier for a NWS Regional HQ.
type NWSRegionalHQId string

// NWSZoneID UGC identifier for a NWS forecast zone or county.
// The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations).
// The third letter will be Z for public/fire zone or C for county.
type NWSZoneID = string

// NWSZoneType defines model for NWSZoneType.
type NWSZoneType string

// Observation defines model for Observation.
type Observation struct {
	Context *JsonLdContext   `json:"@context,omitempty"`
	Id      *string          `json:"@id,omitempty"`
	Type    *ObservationType `json:"@type,omitempty"`

	// BarometricPressure A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	BarometricPressure *QuantitativeValue `json:"barometricPressure,omitempty"`
	CloudLayers        *[]struct {
		Amount MetarSkyCoverage `json:"amount"`

		// Base A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
		Base QuantitativeValue `json:"base"`
	} `json:"cloudLayers"`

	// Dewpoint A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Dewpoint *QuantitativeValue `json:"dewpoint,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// HeatIndex A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	HeatIndex *QuantitativeValue `json:"heatIndex,omitempty"`
	Icon      *string            `json:"icon"`

	// MaxTemperatureLast24Hours A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	MaxTemperatureLast24Hours *QuantitativeValue `json:"maxTemperatureLast24Hours,omitempty"`

	// MinTemperatureLast24Hours A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	MinTemperatureLast24Hours *QuantitativeValue `json:"minTemperatureLast24Hours,omitempty"`

	// PrecipitationLast3Hours A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	PrecipitationLast3Hours *QuantitativeValue `json:"precipitationLast3Hours,omitempty"`

	// PrecipitationLast6Hours A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	PrecipitationLast6Hours *QuantitativeValue `json:"precipitationLast6Hours,omitempty"`

	// PrecipitationLastHour A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	PrecipitationLastHour *QuantitativeValue `json:"precipitationLastHour,omitempty"`
	PresentWeather        *[]MetarPhenomenon `json:"presentWeather,omitempty"`
	RawMessage            *string            `json:"rawMessage,omitempty"`

	// RelativeHumidity A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	RelativeHumidity *QuantitativeValue `json:"relativeHumidity,omitempty"`

	// SeaLevelPressure A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	SeaLevelPressure *QuantitativeValue `json:"seaLevelPressure,omitempty"`
	Station          *string            `json:"station,omitempty"`

	// Temperature A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Temperature     *QuantitativeValue `json:"temperature,omitempty"`
	TextDescription *string            `json:"textDescription,omitempty"`
	Timestamp       *time.Time         `json:"timestamp,omitempty"`

	// Visibility A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Visibility *QuantitativeValue `json:"visibility,omitempty"`

	// WindChill A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindChill *QuantitativeValue `json:"windChill,omitempty"`

	// WindDirection A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindDirection *QuantitativeValue `json:"windDirection,omitempty"`

	// WindGust A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindGust *QuantitativeValue `json:"windGust,omitempty"`

	// WindSpeed A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	WindSpeed *QuantitativeValue `json:"windSpeed,omitempty"`
}

// ObservationType defines model for Observation.Type.
type ObservationType string

// ObservationCollectionGeoJson defines model for ObservationCollectionGeoJson.
type ObservationCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *Observation `json:"properties,omitempty"`
	} `json:"features"`
	Type ObservationCollectionGeoJsonType `json:"type"`
}

// ObservationCollectionGeoJsonType defines model for ObservationCollectionGeoJson.Type.
type ObservationCollectionGeoJsonType string

// ObservationCollectionJsonLd defines model for ObservationCollectionJsonLd.
type ObservationCollectionJsonLd struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]Observation `json:"@graph,omitempty"`
}

// ObservationGeoJson defines model for ObservationGeoJson.
type ObservationGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry       `json:"geometry"`
	Id         *string                `json:"id,omitempty"`
	Properties Observation            `json:"properties"`
	Type       ObservationGeoJsonType `json:"type"`
}

// ObservationGeoJsonType defines model for ObservationGeoJson.Type.
type ObservationGeoJsonType string

// ObservationJsonLd defines model for ObservationJsonLd.
type ObservationJsonLd = Observation

// ObservationStation defines model for ObservationStation.
type ObservationStation struct {
	Context *JsonLdContext          `json:"@context,omitempty"`
	Id      *string                 `json:"@id,omitempty"`
	Type    *ObservationStationType `json:"@type,omitempty"`

	// County A link to the NWS county zone containing this station.
	County *string `json:"county,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// FireWeatherZone A link to the NWS fire weather forecast zone containing this station.
	FireWeatherZone *string `json:"fireWeatherZone,omitempty"`

	// Forecast A link to the NWS public forecast zone containing this station.
	Forecast *string `json:"forecast,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry          *GeometryString `json:"geometry"`
	Name              *string         `json:"name,omitempty"`
	StationIdentifier *string         `json:"stationIdentifier,omitempty"`
	TimeZone          *string         `json:"timeZone,omitempty"`
}

// ObservationStationType defines model for ObservationStation.Type.
type ObservationStationType string

// ObservationStationCollectionGeoJson defines model for ObservationStationCollectionGeoJson.
type ObservationStationCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *ObservationStation `json:"properties,omitempty"`
	} `json:"features"`
	ObservationStations *[]string `json:"observationStations,omitempty"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo                         `json:"pagination,omitempty"`
	Type       ObservationStationCollectionGeoJsonType `json:"type"`
}

// ObservationStationCollectionGeoJsonType defines model for ObservationStationCollectionGeoJson.Type.
type ObservationStationCollectionGeoJsonType string

// ObservationStationCollectionJsonLd defines model for ObservationStationCollectionJsonLd.
type ObservationStationCollectionJsonLd struct {
	Context             *JsonLdContext        `json:"@context,omitempty"`
	Graph               *[]ObservationStation `json:"@graph,omitempty"`
	ObservationStations *[]string             `json:"observationStations,omitempty"`

	// Pagination Links for retrieving more data from paged data sets
	Pagination *PaginationInfo `json:"pagination,omitempty"`
}

// ObservationStationGeoJson defines model for ObservationStationGeoJson.
type ObservationStationGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry              `json:"geometry"`
	Id         *string                       `json:"id,omitempty"`
	Properties ObservationStation            `json:"properties"`
	Type       ObservationStationGeoJsonType `json:"type"`
}

// ObservationStationGeoJsonType defines model for ObservationStationGeoJson.Type.
type ObservationStationGeoJsonType string

// ObservationStationJsonLd defines model for ObservationStationJsonLd.
type ObservationStationJsonLd struct {
	Context JsonLdContext                 `json:"@context"`
	Id      *string                       `json:"@id,omitempty"`
	Type    *ObservationStationJsonLdType `json:"@type,omitempty"`

	// County A link to the NWS county zone containing this station.
	County *string `json:"county,omitempty"`

	// Elevation A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Elevation *QuantitativeValue `json:"elevation,omitempty"`

	// FireWeatherZone A link to the NWS fire weather forecast zone containing this station.
	FireWeatherZone *string `json:"fireWeatherZone,omitempty"`

	// Forecast A link to the NWS public forecast zone containing this station.
	Forecast *string `json:"forecast,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry          *GeometryString `json:"geometry"`
	Name              *string         `json:"name,omitempty"`
	StationIdentifier *string         `json:"stationIdentifier,omitempty"`
	TimeZone          *string         `json:"timeZone,omitempty"`
}

// ObservationStationJsonLdType defines model for ObservationStationJsonLd.Type.
type ObservationStationJsonLdType string

// Office defines model for Office.
type Office struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Type    *OfficeType    `json:"@type,omitempty"`
	Address *struct {
		Type            *OfficeAddressType `json:"@type,omitempty"`
		AddressLocality *string            `json:"addressLocality,omitempty"`
		AddressRegion   *string            `json:"addressRegion,omitempty"`
		PostalCode      *string            `json:"postalCode,omitempty"`
		StreetAddress   *string            `json:"streetAddress,omitempty"`
	} `json:"address,omitempty"`
	ApprovedObservationStations *[]string `json:"approvedObservationStations,omitempty"`
	Email                       *string   `json:"email,omitempty"`
	FaxNumber                   *string   `json:"faxNumber,omitempty"`
	Id                          *string   `json:"id,omitempty"`
	Name                        *string   `json:"name,omitempty"`
	NwsRegion                   *string   `json:"nwsRegion,omitempty"`
	ParentOrganization          *string   `json:"parentOrganization,omitempty"`
	ResponsibleCounties         *[]string `json:"responsibleCounties,omitempty"`
	ResponsibleFireZones        *[]string `json:"responsibleFireZones,omitempty"`
	ResponsibleForecastZones    *[]string `json:"responsibleForecastZones,omitempty"`
	SameAs                      *string   `json:"sameAs,omitempty"`
	Telephone                   *string   `json:"telephone,omitempty"`
}

// OfficeType defines model for Office.Type.
type OfficeType string

// OfficeAddressType defines model for Office.Address.Type.
type OfficeAddressType string

// OfficeHeadline defines model for OfficeHeadline.
type OfficeHeadline struct {
	Context      *JsonLdContext `json:"@context,omitempty"`
	Id           *string        `json:"@id,omitempty"`
	Content      *string        `json:"content,omitempty"`
	Important    *bool          `json:"important,omitempty"`
	IssuanceTime *time.Time     `json:"issuanceTime,omitempty"`
	Link         *string        `json:"link,omitempty"`
	Name         *string        `json:"name,omitempty"`
	Office       *string        `json:"office,omitempty"`
	Summary      *string        `json:"summary"`
	Title        *string        `json:"title,omitempty"`
}

// OfficeHeadlineCollection defines model for OfficeHeadlineCollection.
type OfficeHeadlineCollection struct {
	Context JsonLdContext    `json:"@context"`
	Graph   []OfficeHeadline `json:"@graph"`
}

// PaginationInfo Links for retrieving more data from paged data sets
type PaginationInfo struct {
	// Next A link to the next page of records
	Next string `json:"next"`
}

// Point defines model for Point.
type Point struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Id      *string        `json:"@id,omitempty"`
	Type    *PointType     `json:"@type,omitempty"`
	County  *string        `json:"county,omitempty"`

	// Cwa Three-letter identifier for a NWS office.
	Cwa              *NWSForecastOfficeId `json:"cwa,omitempty"`
	FireWeatherZone  *string              `json:"fireWeatherZone,omitempty"`
	Forecast         *string              `json:"forecast,omitempty"`
	ForecastGridData *string              `json:"forecastGridData,omitempty"`
	ForecastHourly   *string              `json:"forecastHourly,omitempty"`
	ForecastOffice   *string              `json:"forecastOffice,omitempty"`
	ForecastZone     *string              `json:"forecastZone,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// GridId Three-letter identifier for a NWS office.
	GridId              *NWSForecastOfficeId    `json:"gridId,omitempty"`
	GridX               *int                    `json:"gridX,omitempty"`
	GridY               *int                    `json:"gridY,omitempty"`
	ObservationStations *string                 `json:"observationStations,omitempty"`
	RadarStation        *string                 `json:"radarStation,omitempty"`
	RelativeLocation    *Point_RelativeLocation `json:"relativeLocation,omitempty"`
	TimeZone            *string                 `json:"timeZone,omitempty"`
}

// PointType defines model for Point.Type.
type PointType string

// Point_RelativeLocation defines model for Point.RelativeLocation.
type Point_RelativeLocation struct {
	union json.RawMessage
}

// PointGeoJson defines model for PointGeoJson.
type PointGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry `json:"geometry"`
	Id         *string          `json:"id,omitempty"`
	Properties Point            `json:"properties"`
	Type       PointGeoJsonType `json:"type"`
}

// PointGeoJsonType defines model for PointGeoJson.Type.
type PointGeoJsonType string

// PointJsonLd defines model for PointJsonLd.
type PointJsonLd struct {
	Context JsonLdContext    `json:"@context"`
	Id      *string          `json:"@id,omitempty"`
	Type    *PointJsonLdType `json:"@type,omitempty"`
	County  *string          `json:"county,omitempty"`

	// Cwa Three-letter identifier for a NWS office.
	Cwa              *NWSForecastOfficeId `json:"cwa,omitempty"`
	FireWeatherZone  *string              `json:"fireWeatherZone,omitempty"`
	Forecast         *string              `json:"forecast,omitempty"`
	ForecastGridData *string              `json:"forecastGridData,omitempty"`
	ForecastHourly   *string              `json:"forecastHourly,omitempty"`
	ForecastOffice   *string              `json:"forecastOffice,omitempty"`
	ForecastZone     *string              `json:"forecastZone,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// GridId Three-letter identifier for a NWS office.
	GridId              *NWSForecastOfficeId          `json:"gridId,omitempty"`
	GridX               *int                          `json:"gridX,omitempty"`
	GridY               *int                          `json:"gridY,omitempty"`
	ObservationStations *string                       `json:"observationStations,omitempty"`
	RadarStation        *string                       `json:"radarStation,omitempty"`
	RelativeLocation    *PointJsonLd_RelativeLocation `json:"relativeLocation,omitempty"`
	TimeZone            *string                       `json:"timeZone,omitempty"`
}

// PointJsonLdType defines model for PointJsonLd.Type.
type PointJsonLdType string

// PointJsonLd_RelativeLocation defines model for PointJsonLd.RelativeLocation.
type PointJsonLd_RelativeLocation struct {
	union json.RawMessage
}

// PointString defines model for PointString.
type PointString = string

// ProblemDetail Detail about an error. This document conforms to RFC 7807 (Problem Details for HTTP APIs).
type ProblemDetail struct {
	// CorrelationId A unique identifier for the request, used for NWS debugging purposes. Please include this identifier with any correspondence to help us investigate your issue.
	CorrelationId string `json:"correlationId"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Instance A URI reference (RFC 3986) that identifies the specific occurrence of the problem. This is only an identifier and is not necessarily a resolvable URL.
	Instance string `json:"instance"`

	// Status The HTTP status code (RFC 7231, Section 6) generated by the origin server for this occurrence of the problem.
	Status float32 `json:"status"`

	// Title A short, human-readable summary of the problem type.
	Title string `json:"title"`

	// Type A URI reference (RFC 3986) that identifies the problem type. This is only an identifier and is not necessarily a resolvable URL.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// QuantitativeValue A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
type QuantitativeValue struct {
	// MaxValue The maximum value of a range of measured values
	MaxValue *float32 `json:"maxValue,omitempty"`

	// MinValue The minimum value of a range of measured values
	MinValue *float32 `json:"minValue,omitempty"`

	// QualityControl For values in observation records, the quality control flag from the MADIS system. The definitions of these flags can be found at https://madis.ncep.noaa.gov/madis_sfc_qc_notes.shtml
	QualityControl *QuantitativeValueQualityControl `json:"qualityControl,omitempty"`

	// UnitCode A string denoting a unit of measure, expressed in the format "{unit}" or "{namespace}:{unit}".
	// Units with the namespace "wmo" or "wmoUnit" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}.
	// Units with the namespace "nwsUnit" are currently custom and do not align to any standard.
	// Units with no namespace or the namespace "uc" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156).
	// Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
	UnitCode *UnitOfMeasure `json:"unitCode,omitempty"`

	// Value A measured value
	Value *float32 `json:"value"`
}

// QuantitativeValueQualityControl For values in observation records, the quality control flag from the MADIS system. The definitions of these flags can be found at https://madis.ncep.noaa.gov/madis_sfc_qc_notes.shtml
type QuantitativeValueQualityControl string

// RegionCode defines model for RegionCode.
type RegionCode struct {
	union json.RawMessage
}

// RelativeLocation defines model for RelativeLocation.
type RelativeLocation struct {
	// Bearing A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Bearing *QuantitativeValue `json:"bearing,omitempty"`
	City    *string            `json:"city,omitempty"`

	// Distance A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Distance *QuantitativeValue `json:"distance,omitempty"`
	State    *string            `json:"state,omitempty"`
}

// RelativeLocationGeoJson defines model for RelativeLocationGeoJson.
type RelativeLocationGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry            `json:"geometry"`
	Id         *string                     `json:"id,omitempty"`
	Properties RelativeLocation            `json:"properties"`
	Type       RelativeLocationGeoJsonType `json:"type"`
}

// RelativeLocationGeoJsonType defines model for RelativeLocationGeoJson.Type.
type RelativeLocationGeoJsonType string

// RelativeLocationJsonLd defines model for RelativeLocationJsonLd.
type RelativeLocationJsonLd struct {
	// Bearing A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Bearing *QuantitativeValue `json:"bearing,omitempty"`
	City    *string            `json:"city,omitempty"`

	// Distance A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
	Distance *QuantitativeValue `json:"distance,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`
	State    *string         `json:"state,omitempty"`
}

// Sigmet defines model for Sigmet.
type Sigmet struct {
	// Atsu ATSU Identifier
	ATSUIdentifierString *ATSUIdentifierString `json:"atsu,omitempty"`
	End                  *time.Time            `json:"end,omitempty"`
	Fir                  *string               `json:"fir"`
	Id                   *string               `json:"id,omitempty"`
	IssueTime            *time.Time            `json:"issueTime,omitempty"`
	Phenomenon           *string               `json:"phenomenon"`
	Sequence             *string               `json:"sequence"`
	Start                *time.Time            `json:"start,omitempty"`
}

// SigmetCollectionGeoJson defines model for SigmetCollectionGeoJson.
type SigmetCollectionGeoJson struct {
	Context  *JsonLdContext              `json:"@context,omitempty"`
	Features []SigmetGeoJson             `json:"features"`
	Type     SigmetCollectionGeoJsonType `json:"type"`
}

// SigmetCollectionGeoJsonType defines model for SigmetCollectionGeoJson.Type.
type SigmetCollectionGeoJsonType string

// SigmetGeoJson defines model for SigmetGeoJson.
type SigmetGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry  `json:"geometry"`
	Id         *string           `json:"id,omitempty"`
	Properties Sigmet            `json:"properties"`
	Type       SigmetGeoJsonType `json:"type"`
}

// SigmetGeoJsonType defines model for SigmetGeoJson.Type.
type SigmetGeoJsonType string

// SigmetSequenceNumber defines model for SigmetSequenceNumber.
type SigmetSequenceNumber = string

// StateTerritoryCode defines model for StateTerritoryCode.
type StateTerritoryCode string

// TextProduct defines model for TextProduct.
type TextProduct struct {
	Context         *JsonLdContext `json:"@context,omitempty"`
	Id              *string        `json:"id,omitempty"`
	IssuanceTime    *time.Time     `json:"issuanceTime,omitempty"`
	IssuingOffice   *string        `json:"issuingOffice,omitempty"`
	ProductCode     *string        `json:"productCode,omitempty"`
	ProductName     *string        `json:"productName,omitempty"`
	ProductText     *string        `json:"productText,omitempty"`
	WmoCollectiveId *string        `json:"wmoCollectiveId,omitempty"`
}

// TextProductCollection defines model for TextProductCollection.
type TextProductCollection struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]TextProduct `json:"@graph,omitempty"`
}

// TextProductLocationCollection defines model for TextProductLocationCollection.
type TextProductLocationCollection struct {
	Context   *JsonLdContext     `json:"@context,omitempty"`
	Locations *map[string]string `json:"locations,omitempty"`
}

// TextProductTypeCollection defines model for TextProductTypeCollection.
type TextProductTypeCollection struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]struct {
		ProductCode string `json:"productCode"`
		ProductName string `json:"productName"`
	} `json:"@graph,omitempty"`
}

// TimeString A time (in HHMM format). This is always specified in UTC (Zulu) time.
type TimeString = string

// UnitOfMeasure A string denoting a unit of measure, expressed in the format "{unit}" or "{namespace}:{unit}".
// Units with the namespace "wmo" or "wmoUnit" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}.
// Units with the namespace "nwsUnit" are currently custom and do not align to any standard.
// Units with no namespace or the namespace "uc" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156).
// Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
type UnitOfMeasure = string

// Zone defines model for Zone.
type Zone struct {
	Context         *JsonLdContext         `json:"@context,omitempty"`
	Cwa             *[]NWSForecastOfficeId `json:"cwa,omitempty"`
	EffectiveDate   *time.Time             `json:"effectiveDate,omitempty"`
	ExpirationDate  *time.Time             `json:"expirationDate,omitempty"`
	ForecastOffices *[]string              `json:"forecastOffices,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Id UGC identifier for a NWS forecast zone or county.
	// The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations).
	// The third letter will be Z for public/fire zone or C for county.
	Id                  *NWSZoneID   `json:"id,omitempty"`
	Name                *string      `json:"name,omitempty"`
	ObservationStations *[]string    `json:"observationStations,omitempty"`
	RadarStation        *string      `json:"radarStation"`
	State               *Zone_State  `json:"state,omitempty"`
	TimeZone            *[]string    `json:"timeZone,omitempty"`
	Type                *NWSZoneType `json:"type,omitempty"`
}

// ZoneType defines model for Zone.Type.
type ZoneType string

// ZoneState1 defines model for .
type ZoneState1 ZoneState

// ZoneState defines model for Zone.State.
type ZoneState struct {
	union json.RawMessage
}

// Zone_State defines model for Zone.State.
type Zone_State struct {
	union json.RawMessage
}
// ZoneCollectionGeoJson defines model for ZoneCollectionGeoJson.
type ZoneCollectionGeoJson struct {
	Context  *JsonLdContext `json:"@context,omitempty"`
	Features []struct {
		Properties *Zone `json:"properties,omitempty"`
	} `json:"features"`
	Type ZoneCollectionGeoJsonType `json:"type"`
}

// ZoneCollectionGeoJsonType defines model for ZoneCollectionGeoJson.Type.
type ZoneCollectionGeoJsonType string

// ZoneCollectionJsonLd defines model for ZoneCollectionJsonLd.
type ZoneCollectionJsonLd struct {
	Context *JsonLdContext `json:"@context,omitempty"`
	Graph   *[]Zone        `json:"@graph,omitempty"`
}

// ZoneForecast An object representing a zone area forecast.
type ZoneForecast struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A geometry represented in Well-Known Text (WKT) format.
	Geometry *GeometryString `json:"geometry"`

	// Periods An array of forecast periods.
	Periods *[]struct {
		// DetailedForecast A detailed textual forecast for the period.
		DetailedForecast string `json:"detailedForecast"`

		// Name A textual description of the period.
		Name string `json:"name"`

		// Number A sequential identifier number.
		Number int `json:"number"`
	} `json:"periods,omitempty"`

	// Updated The time this zone forecast product was published.
	Updated *time.Time `json:"updated,omitempty"`

	// Zone An API link to the zone this forecast is for.
	Zone *string `json:"zone,omitempty"`
}

// ZoneForecastGeoJson defines model for ZoneForecastGeoJson.
type ZoneForecastGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry *GeoJsonGeometry `json:"geometry"`
	Id       *string          `json:"id,omitempty"`

	// Properties An object representing a zone area forecast.
	Properties ZoneForecast            `json:"properties"`
	Type       ZoneForecastGeoJsonType `json:"type"`
}

// ZoneForecastGeoJsonType defines model for ZoneForecastGeoJson.Type.
type ZoneForecastGeoJsonType string

// ZoneForecastJsonLd An object representing a zone area forecast.
type ZoneForecastJsonLd = ZoneForecast

// ZoneGeoJson defines model for ZoneGeoJson.
type ZoneGeoJson struct {
	Context *JsonLdContext `json:"@context,omitempty"`

	// Geometry A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
	Geometry   *GeoJsonGeometry `json:"geometry"`
	Id         *string          `json:"id,omitempty"`
	Properties Zone             `json:"properties"`
	Type       ZoneGeoJsonType  `json:"type"`
}

// ZoneGeoJsonType defines model for ZoneGeoJson.Type.
type ZoneGeoJsonType string

// ZoneJsonLd defines model for ZoneJsonLd.
type ZoneJsonLd = Zone

// ATSUIdentifier ATSU Identifier
type ATSUIdentifier = ATSUIdentifierString

// AlertArea defines model for AlertArea.
type AlertArea = []AreaCode

// AlertCertainty defines model for AlertCertainty.
type AlertCertainty = []AlertCertaintyEnum

// AlertCode defines model for AlertCode.
type AlertCode = []string

// AlertEventName defines model for AlertEventName.
type AlertEventName = []string

// AlertMessageType defines model for AlertMessageType.
type AlertMessageType = []string

// AlertPoint defines model for AlertPoint.
type AlertPoint = PointString

// AlertRegion defines model for AlertRegion.
type AlertRegion = []MarineRegionCode

// AlertRegionType defines model for AlertRegionType.
type AlertRegionType string

// AlertSeverity defines model for AlertSeverity.
type AlertSeverity = []AlertSeverityEnum

// AlertStatus defines model for AlertStatus.
type AlertStatus = []string

// AlertUrgency defines model for AlertUrgency.
type AlertUrgency = []AlertUrgencyEnum

// AlertZone defines model for AlertZone.
type AlertZone = []NWSZoneID

// Date Date (in YYYY-MM-DD format).
type Date = DateString

// GridpointForecastFeatureFlags defines model for GridpointForecastFeatureFlags.
type GridpointForecastFeatureFlags = []string

// GridpointForecastUnits Denotes the units used in the textual portions of the forecast.
type GridpointForecastUnits = GridpointForecastUnitsEnum

// GridpointWFO Three-letter identifier for a NWS office.
type GridpointWFO = NWSForecastOfficeId

// GridpointX defines model for GridpointX.
type GridpointX = int

// GridpointY defines model for GridpointY.
type GridpointY = int

// Limit defines model for Limit.
type Limit = int

// NWSCenterWeatherServiceUnitId Three-letter identifier for a Center Weather Service Unit (CWSU).
type NWSCenterWeatherServiceUnitId = NWSCenterWeatherServiceUnitIdEnum

// NWSOfficeIdReference defines model for NWSOfficeId.
type NWSOfficeIdReference = NWSOfficeId

// NWSZoneId UGC identifier for a NWS forecast zone or county.
// The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations).
// The third letter will be Z for public/fire zone or C for county.
type NWSZoneId = NWSZoneID

// ObservationStationId defines model for ObservationStationId.
type ObservationStationId = string

// PaginationCursor defines model for PaginationCursor.
type PaginationCursor = string

// PathPoint defines model for PathPoint.
type PathPoint = PointString

// QueryDate Date (in YYYY-MM-DD format).
type QueryDate = DateString

// QueryEndTime defines model for QueryEndTime.
type QueryEndTime = time.Time

// QueryStartTime defines model for QueryStartTime.
type QueryStartTime = time.Time

// Time A time (in HHMM format). This is always specified in UTC (Zulu) time.
type Time = TimeString

// AlertsQueryParams defines parameters for AlertsQuery.
type AlertsQueryParams struct {
	// Active List only active alerts (use /alerts/active endpoints instead)
	Active *bool `form:"active,omitempty" json:"active,omitempty"`

	// Start Start time
	Start *QueryStartTime `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *QueryEndTime `form:"end,omitempty" json:"end,omitempty"`

	// Status Status (actual, exercise, system, test, draft)
	Status *AlertStatus `form:"status,omitempty" json:"status,omitempty"`

	// MessageType Message type (alert, update, cancel)
	MessageType *AlertMessageType `form:"message_type,omitempty" json:"message_type,omitempty"`

	// Event Event name
	Event *AlertEventName `form:"event,omitempty" json:"event,omitempty"`

	// Code Event code
	Code *AlertCode `form:"code,omitempty" json:"code,omitempty"`

	// Area State/territory code or marine area code
	// This parameter is incompatible with the following parameters: point, region, region_type, zone
	Area *AlertArea `form:"area,omitempty" json:"area,omitempty"`

	// Point Point (latitude,longitude)
	// This parameter is incompatible with the following parameters: area, region, region_type, zone
	Point *AlertPoint `form:"point,omitempty" json:"point,omitempty"`

	// Region Marine region code
	// This parameter is incompatible with the following parameters: area, point, region_type, zone
	Region *AlertRegion `form:"region,omitempty" json:"region,omitempty"`

	// RegionType Region type (land or marine)
	// This parameter is incompatible with the following parameters: area, point, region, zone
	RegionType *AlertsQueryParamsRegionType `form:"region_type,omitempty" json:"region_type,omitempty"`

	// Zone Zone ID (forecast or county)
	// This parameter is incompatible with the following parameters: area, point, region, region_type
	Zone *AlertZone `form:"zone,omitempty" json:"zone,omitempty"`

	// Urgency Urgency (immediate, expected, future, past, unknown)
	Urgency *AlertUrgency `form:"urgency,omitempty" json:"urgency,omitempty"`

	// Severity Severity (extreme, severe, moderate, minor, unknown)
	Severity *AlertSeverity `form:"severity,omitempty" json:"severity,omitempty"`

	// Certainty Certainty (observed, likely, possible, unlikely, unknown)
	Certainty *AlertCertainty `form:"certainty,omitempty" json:"certainty,omitempty"`

	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// AlertsQueryParamsStatus defines parameters for AlertsQuery.
type AlertsQueryParamsStatus string

// AlertsQueryParamsMessageType defines parameters for AlertsQuery.
type AlertsQueryParamsMessageType string

// AlertsQueryParamsRegionType defines parameters for AlertsQuery.
type AlertsQueryParamsRegionType string

// AlertsActiveParams defines parameters for AlertsActive.
type AlertsActiveParams struct {
	// Status Status (actual, exercise, system, test, draft)
	Status *AlertStatus `form:"status,omitempty" json:"status,omitempty"`

	// MessageType Message type (alert, update, cancel)
	MessageType *AlertMessageType `form:"message_type,omitempty" json:"message_type,omitempty"`

	// Event Event name
	Event *AlertEventName `form:"event,omitempty" json:"event,omitempty"`

	// Code Event code
	Code *AlertCode `form:"code,omitempty" json:"code,omitempty"`

	// Area State/territory code or marine area code
	// This parameter is incompatible with the following parameters: point, region, region_type, zone
	Area *AlertArea `form:"area,omitempty" json:"area,omitempty"`

	// Point Point (latitude,longitude)
	// This parameter is incompatible with the following parameters: area, region, region_type, zone
	Point *AlertPoint `form:"point,omitempty" json:"point,omitempty"`

	// Region Marine region code
	// This parameter is incompatible with the following parameters: area, point, region_type, zone
	Region *AlertRegion `form:"region,omitempty" json:"region,omitempty"`

	// RegionType Region type (land or marine)
	// This parameter is incompatible with the following parameters: area, point, region, zone
	RegionType *AlertsActiveParamsRegionType `form:"region_type,omitempty" json:"region_type,omitempty"`

	// Zone Zone ID (forecast or county)
	// This parameter is incompatible with the following parameters: area, point, region, region_type
	Zone *AlertZone `form:"zone,omitempty" json:"zone,omitempty"`

	// Urgency Urgency (immediate, expected, future, past, unknown)
	Urgency *AlertUrgency `form:"urgency,omitempty" json:"urgency,omitempty"`

	// Severity Severity (extreme, severe, moderate, minor, unknown)
	Severity *AlertSeverity `form:"severity,omitempty" json:"severity,omitempty"`

	// Certainty Certainty (observed, likely, possible, unlikely, unknown)
	Certainty *AlertCertainty `form:"certainty,omitempty" json:"certainty,omitempty"`

	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// AlertsActiveParamsStatus defines parameters for AlertsActive.
type AlertsActiveParamsStatus string

// AlertsActiveParamsMessageType defines parameters for AlertsActive.
type AlertsActiveParamsMessageType string

// AlertsActiveParamsRegionType defines parameters for AlertsActive.
type AlertsActiveParamsRegionType string

// SigmetQueryParams defines parameters for SigmetQuery.
type SigmetQueryParams struct {
	// Start Start time
	Start *QueryStartTime `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *QueryEndTime `form:"end,omitempty" json:"end,omitempty"`

	// Date Date (YYYY-MM-DD format)
	Date *QueryDate `form:"date,omitempty" json:"date,omitempty"`

	// Atsu ATSU identifier
	Atsu *ATSUIdentifierString `form:"atsu,omitempty" json:"atsu,omitempty"`

	// Sequence SIGMET sequence number
	Sequence *SigmetSequenceNumber `form:"sequence,omitempty" json:"sequence,omitempty"`
}

// GridpointForecastParams defines parameters for GridpointForecast.
type GridpointForecastParams struct {
	// Units Use US customary or SI (metric) units in textual output
	Units *GridpointForecastUnits `form:"units,omitempty" json:"units,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * forecast_temperature_qv: Represent temperature as QuantitativeValue
	// * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
	FeatureFlags *GridpointForecastFeatureFlags `json:"Feature-Flags,omitempty"`
}

// GridpointForecastParamsFeatureFlags defines parameters for GridpointForecast.
type GridpointForecastParamsFeatureFlags string

// GridpointForecastHourlyParams defines parameters for GridpointForecastHourly.
type GridpointForecastHourlyParams struct {
	// Units Use US customary or SI (metric) units in textual output
	Units *GridpointForecastUnits `form:"units,omitempty" json:"units,omitempty"`

	// FeatureFlags Enable future and experimental features (see documentation for more info):
	// * forecast_temperature_qv: Represent temperature as QuantitativeValue
	// * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
	FeatureFlags *GridpointForecastFeatureFlags `json:"Feature-Flags,omitempty"`
}

// GridpointForecastHourlyParamsFeatureFlags defines parameters for GridpointForecastHourly.
type GridpointForecastHourlyParamsFeatureFlags string

// GridpointStationsParams defines parameters for GridpointStations.
type GridpointStationsParams struct {
	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// IconsParams defines parameters for Icons.
type IconsParams struct {
	// Size Font size
	Size *struct {
		union json.RawMessage
	} `form:"size,omitempty" json:"size,omitempty"`

	// Fontsize Font size
	Fontsize *int `form:"fontsize,omitempty" json:"fontsize,omitempty"`
}

// Size0 defines parameters for Icons.
type Size0 string

// Size1 defines parameters for Icons.
type Size1 = int

// IconsDualConditionParams defines parameters for IconsDualCondition.
type IconsDualConditionParams struct {
	// Size Font size
	Size *struct {
		union json.RawMessage
	} `form:"size,omitempty" json:"size,omitempty"`

	// Fontsize Font size
	Fontsize *int `form:"fontsize,omitempty" json:"fontsize,omitempty"`
}

// ProductsQueryParams defines parameters for ProductsQuery.
type ProductsQueryParams struct {
	// Location Location id
	Location *[]string `form:"location,omitempty" json:"location,omitempty"`

	// Start Start time
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Office Issuing office
	Office *[]string `form:"office,omitempty" json:"office,omitempty"`

	// Wmoid WMO id code
	Wmoid *[]string `form:"wmoid,omitempty" json:"wmoid,omitempty"`

	// Type Product code
	Type *[]string `form:"type,omitempty" json:"type,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// RadarProfilerParams defines parameters for RadarProfiler.
type RadarProfilerParams struct {
	// Time Time interval
	Time *ISO8601Interval `form:"time,omitempty" json:"time,omitempty"`

	// Interval Averaging interval
	Interval *ISO8601Duration `form:"interval,omitempty" json:"interval,omitempty"`
}

// RadarQueueParams defines parameters for RadarQueue.
type RadarQueueParams struct {
	// Limit Record limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Arrived Range for arrival time
	Arrived *ISO8601Interval `form:"arrived,omitempty" json:"arrived,omitempty"`

	// Created Range for creation time
	Created *ISO8601Interval `form:"created,omitempty" json:"created,omitempty"`

	// Published Range for publish time
	Published *ISO8601Interval `form:"published,omitempty" json:"published,omitempty"`

	// Station Station identifier
	Station *string `form:"station,omitempty" json:"station,omitempty"`

	// Type Record type
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Feed Originating product feed
	Feed *string `form:"feed,omitempty" json:"feed,omitempty"`

	// Resolution Resolution version
	Resolution *int `form:"resolution,omitempty" json:"resolution,omitempty"`
}

// RadarServersParams defines parameters for RadarServers.
type RadarServersParams struct {
	// ReportingHost Show records from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`
}

// RadarServerParams defines parameters for RadarServer.
type RadarServerParams struct {
	// ReportingHost Show records from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`
}

// RadarStationsParams defines parameters for RadarStations.
type RadarStationsParams struct {
	// StationType Limit results to a specific station type or types
	StationType *[]string `form:"stationType,omitempty" json:"stationType,omitempty"`

	// ReportingHost Show RDA and latency info from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`

	// Host Show latency info from specific LDM host
	Host *string `form:"host,omitempty" json:"host,omitempty"`
}

// RadarStationParams defines parameters for RadarStation.
type RadarStationParams struct {
	// ReportingHost Show RDA and latency info from specific reporting host
	ReportingHost *string `form:"reportingHost,omitempty" json:"reportingHost,omitempty"`

	// Host Show latency info from specific LDM host
	Host *string `form:"host,omitempty" json:"host,omitempty"`
}

// ObsStationsParams defines parameters for ObsStations.
type ObsStationsParams struct {
	// Id Filter by observation station ID
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// State Filter by state/marine area code
	State *[]AreaCode `form:"state,omitempty" json:"state,omitempty"`

	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// StationObservationListParams defines parameters for StationObservationList.
type StationObservationListParams struct {
	// Start Start time
	Start *QueryStartTime `form:"start,omitempty" json:"start,omitempty"`

	// End End time
	End *QueryEndTime `form:"end,omitempty" json:"end,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// StationObservationLatestParams defines parameters for StationObservationLatest.
type StationObservationLatestParams struct {
	// RequireQc Require QC
	RequireQc *bool `form:"require_qc,omitempty" json:"require_qc,omitempty"`
}

// ZoneListParams defines parameters for ZoneList.
type ZoneListParams struct {
	// Id Zone ID (forecast or county)
	Id *[]NWSZoneID `form:"id,omitempty" json:"id,omitempty"`

	// Area State/marine area code
	Area *[]AreaCode `form:"area,omitempty" json:"area,omitempty"`

	// Region Region code
	Region *[]RegionCode `form:"region,omitempty" json:"region,omitempty"`

	// Type Zone type
	Type *[]NWSZoneType `form:"type,omitempty" json:"type,omitempty"`

	// Point Point (latitude,longitude)
	Point *PointString `form:"point,omitempty" json:"point,omitempty"`

	// IncludeGeometry Include geometry in results (true/false)
	IncludeGeometry *bool `form:"include_geometry,omitempty" json:"include_geometry,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Effective Effective date/time
	Effective *time.Time `form:"effective,omitempty" json:"effective,omitempty"`
}

// ZoneObsParams defines parameters for ZoneObs.
type ZoneObsParams struct {
	// Start Start date/time
	Start *time.Time `form:"start,omitempty" json:"start,omitempty"`

	// End End date/time
	End *time.Time `form:"end,omitempty" json:"end,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ZoneStationsParams defines parameters for ZoneStations.
type ZoneStationsParams struct {
	// Limit Limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Cursor Pagination cursor
	Cursor *PaginationCursor `form:"cursor,omitempty" json:"cursor,omitempty"`
}

// ZoneListTypeParams defines parameters for ZoneListType.
type ZoneListTypeParams struct {
	// Id Zone ID (forecast or county)
	Id *[]NWSZoneID `form:"id,omitempty" json:"id,omitempty"`

	// Area State/marine area code
	Area *[]AreaCode `form:"area,omitempty" json:"area,omitempty"`

	// Region Region code
	Region *[]RegionCode `form:"region,omitempty" json:"region,omitempty"`

	// Type Zone type
	Type *[]NWSZoneType `form:"type,omitempty" json:"type,omitempty"`

	// Point Point (latitude,longitude)
	Point *PointString `form:"point,omitempty" json:"point,omitempty"`

	// IncludeGeometry Include geometry in results (true/false)
	IncludeGeometry *bool `form:"include_geometry,omitempty" json:"include_geometry,omitempty"`

	// Limit Limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Effective Effective date/time
	Effective *time.Time `form:"effective,omitempty" json:"effective,omitempty"`
}

// ZoneParams defines parameters for Zone.
type ZoneParams struct {
	// Effective Effective date/time
	Effective *time.Time `form:"effective,omitempty" json:"effective,omitempty"`
}

// Getter for additional properties for Gridpoint. Returns the specified
// element and whether it was found
func (a Gridpoint) Get(fieldName string) (value GridpointQuantitativeValueLayer, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Gridpoint
func (a *Gridpoint) Set(fieldName string, value GridpointQuantitativeValueLayer) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]GridpointQuantitativeValueLayer)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Gridpoint to handle AdditionalProperties
func (a *Gridpoint) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["@context"]; found {
		err = json.Unmarshal(raw, &a.Context)
		if err != nil {
			return fmt.Errorf("error reading '@context': %w", err)
		}
		delete(object, "@context")
	}

	if raw, found := object["@id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading '@id': %w", err)
		}
		delete(object, "@id")
	}

	if raw, found := object["@type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading '@type': %w", err)
		}
		delete(object, "@type")
	}

	if raw, found := object["elevation"]; found {
		err = json.Unmarshal(raw, &a.Elevation)
		if err != nil {
			return fmt.Errorf("error reading 'elevation': %w", err)
		}
		delete(object, "elevation")
	}

	if raw, found := object["forecastOffice"]; found {
		err = json.Unmarshal(raw, &a.ForecastOffice)
		if err != nil {
			return fmt.Errorf("error reading 'forecastOffice': %w", err)
		}
		delete(object, "forecastOffice")
	}

	if raw, found := object["geometry"]; found {
		err = json.Unmarshal(raw, &a.Geometry)
		if err != nil {
			return fmt.Errorf("error reading 'geometry': %w", err)
		}
		delete(object, "geometry")
	}

	if raw, found := object["gridId"]; found {
		err = json.Unmarshal(raw, &a.GridId)
		if err != nil {
			return fmt.Errorf("error reading 'gridId': %w", err)
		}
		delete(object, "gridId")
	}

	if raw, found := object["gridX"]; found {
		err = json.Unmarshal(raw, &a.GridX)
		if err != nil {
			return fmt.Errorf("error reading 'gridX': %w", err)
		}
		delete(object, "gridX")
	}

	if raw, found := object["gridY"]; found {
		err = json.Unmarshal(raw, &a.GridY)
		if err != nil {
			return fmt.Errorf("error reading 'gridY': %w", err)
		}
		delete(object, "gridY")
	}

	if raw, found := object["hazards"]; found {
		err = json.Unmarshal(raw, &a.Hazards)
		if err != nil {
			return fmt.Errorf("error reading 'hazards': %w", err)
		}
		delete(object, "hazards")
	}

	if raw, found := object["updateTime"]; found {
		err = json.Unmarshal(raw, &a.UpdateTime)
		if err != nil {
			return fmt.Errorf("error reading 'updateTime': %w", err)
		}
		delete(object, "updateTime")
	}

	if raw, found := object["validTimes"]; found {
		err = json.Unmarshal(raw, &a.ValidTimes)
		if err != nil {
			return fmt.Errorf("error reading 'validTimes': %w", err)
		}
		delete(object, "validTimes")
	}

	if raw, found := object["weather"]; found {
		err = json.Unmarshal(raw, &a.Weather)
		if err != nil {
			return fmt.Errorf("error reading 'weather': %w", err)
		}
		delete(object, "weather")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]GridpointQuantitativeValueLayer)
		for fieldName, fieldBuf := range object {
			var fieldVal GridpointQuantitativeValueLayer
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Gridpoint to handle AdditionalProperties
func (a Gridpoint) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Context != nil {
		object["@context"], err = json.Marshal(a.Context)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@context': %w", err)
		}
	}

	if a.Id != nil {
		object["@id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@id': %w", err)
		}
	}

	if a.Type != nil {
		object["@type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '@type': %w", err)
		}
	}

	if a.Elevation != nil {
		object["elevation"], err = json.Marshal(a.Elevation)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elevation': %w", err)
		}
	}

	if a.ForecastOffice != nil {
		object["forecastOffice"], err = json.Marshal(a.ForecastOffice)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'forecastOffice': %w", err)
		}
	}

	if a.Geometry != nil {
		object["geometry"], err = json.Marshal(a.Geometry)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'geometry': %w", err)
		}
	}

	if a.GridId != nil {
		object["gridId"], err = json.Marshal(a.GridId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gridId': %w", err)
		}
	}

	if a.GridX != nil {
		object["gridX"], err = json.Marshal(a.GridX)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gridX': %w", err)
		}
	}

	if a.GridY != nil {
		object["gridY"], err = json.Marshal(a.GridY)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gridY': %w", err)
		}
	}

	if a.Hazards != nil {
		object["hazards"], err = json.Marshal(a.Hazards)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hazards': %w", err)
		}
	}

	if a.UpdateTime != nil {
		object["updateTime"], err = json.Marshal(a.UpdateTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updateTime': %w", err)
		}
	}

	if a.ValidTimes != nil {
		object["validTimes"], err = json.Marshal(a.ValidTimes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'validTimes': %w", err)
		}
	}

	if a.Weather != nil {
		object["weather"], err = json.Marshal(a.Weather)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'weather': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for ProblemDetail. Returns the specified
// element and whether it was found
func (a ProblemDetail) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for ProblemDetail
func (a *ProblemDetail) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for ProblemDetail to handle AdditionalProperties
func (a *ProblemDetail) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["correlationId"]; found {
		err = json.Unmarshal(raw, &a.CorrelationId)
		if err != nil {
			return fmt.Errorf("error reading 'correlationId': %w", err)
		}
		delete(object, "correlationId")
	}

	if raw, found := object["detail"]; found {
		err = json.Unmarshal(raw, &a.Detail)
		if err != nil {
			return fmt.Errorf("error reading 'detail': %w", err)
		}
		delete(object, "detail")
	}

	if raw, found := object["instance"]; found {
		err = json.Unmarshal(raw, &a.Instance)
		if err != nil {
			return fmt.Errorf("error reading 'instance': %w", err)
		}
		delete(object, "instance")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshalling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for ProblemDetail to handle AdditionalProperties
func (a ProblemDetail) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["correlationId"], err = json.Marshal(a.CorrelationId)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'correlationId': %w", err)
	}

	object["detail"], err = json.Marshal(a.Detail)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'detail': %w", err)
	}

	object["instance"], err = json.Marshal(a.Instance)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'instance': %w", err)
	}

	object["status"], err = json.Marshal(a.Status)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'status': %w", err)
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsStateTerritoryCode returns the union data inside the AreaCode as a StateTerritoryCode
func (t AreaCode) AsStateTerritoryCode() (StateTerritoryCode, error) {
	var body StateTerritoryCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStateTerritoryCode overwrites any union data inside the AreaCode as the provided StateTerritoryCode
func (t *AreaCode) FromStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStateTerritoryCode performs a merge with any union data inside the AreaCode, using the provided StateTerritoryCode
func (t *AreaCode) MergeStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMarineAreaCode returns the union data inside the AreaCode as a MarineAreaCode
func (t AreaCode) AsMarineAreaCode() (MarineAreaCode, error) {
	var body MarineAreaCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarineAreaCode overwrites any union data inside the AreaCode as the provided MarineAreaCode
func (t *AreaCode) FromMarineAreaCode(v MarineAreaCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarineAreaCode performs a merge with any union data inside the AreaCode, using the provided MarineAreaCode
func (t *AreaCode) MergeMarineAreaCode(v MarineAreaCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t AreaCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AreaCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGeoJsonGeometry0 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry0
func (t GeoJsonGeometry) AsGeoJsonGeometry0() (GeoJsonGeometry0, error) {
	var body GeoJsonGeometry0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry0 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry0
func (t *GeoJsonGeometry) FromGeoJsonGeometry0(v GeoJsonGeometry0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry0 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry0
func (t *GeoJsonGeometry) MergeGeoJsonGeometry0(v GeoJsonGeometry0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGeoJsonGeometry1 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry1
func (t GeoJsonGeometry) AsGeoJsonGeometry1() (GeoJsonGeometry1, error) {
	var body GeoJsonGeometry1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry1 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry1
func (t *GeoJsonGeometry) FromGeoJsonGeometry1(v GeoJsonGeometry1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry1 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry1
func (t *GeoJsonGeometry) MergeGeoJsonGeometry1(v GeoJsonGeometry1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGeoJsonGeometry2 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry2
func (t GeoJsonGeometry) AsGeoJsonGeometry2() (GeoJsonGeometry2, error) {
	var body GeoJsonGeometry2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry2 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry2
func (t *GeoJsonGeometry) FromGeoJsonGeometry2(v GeoJsonGeometry2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry2 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry2
func (t *GeoJsonGeometry) MergeGeoJsonGeometry2(v GeoJsonGeometry2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGeoJsonGeometry3 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry3
func (t GeoJsonGeometry) AsGeoJsonGeometry3() (GeoJsonGeometry3, error) {
	var body GeoJsonGeometry3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry3 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry3
func (t *GeoJsonGeometry) FromGeoJsonGeometry3(v GeoJsonGeometry3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry3 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry3
func (t *GeoJsonGeometry) MergeGeoJsonGeometry3(v GeoJsonGeometry3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGeoJsonGeometry4 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry4
func (t GeoJsonGeometry) AsGeoJsonGeometry4() (GeoJsonGeometry4, error) {
	var body GeoJsonGeometry4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry4 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry4
func (t *GeoJsonGeometry) FromGeoJsonGeometry4(v GeoJsonGeometry4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry4 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry4
func (t *GeoJsonGeometry) MergeGeoJsonGeometry4(v GeoJsonGeometry4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGeoJsonGeometry5 returns the union data inside the GeoJsonGeometry as a GeoJsonGeometry5
func (t GeoJsonGeometry) AsGeoJsonGeometry5() (GeoJsonGeometry5, error) {
	var body GeoJsonGeometry5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeoJsonGeometry5 overwrites any union data inside the GeoJsonGeometry as the provided GeoJsonGeometry5
func (t *GeoJsonGeometry) FromGeoJsonGeometry5(v GeoJsonGeometry5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeoJsonGeometry5 performs a merge with any union data inside the GeoJsonGeometry, using the provided GeoJsonGeometry5
func (t *GeoJsonGeometry) MergeGeoJsonGeometry5(v GeoJsonGeometry5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t GeoJsonGeometry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GeoJsonGeometry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the GridpointForecastPeriod_Temperature as a QuantitativeValue
func (t GridpointForecastPeriod_Temperature) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the GridpointForecastPeriod_Temperature as the provided QuantitativeValue
func (t *GridpointForecastPeriod_Temperature) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the GridpointForecastPeriod_Temperature, using the provided QuantitativeValue
func (t *GridpointForecastPeriod_Temperature) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGridpointForecastPeriodTemperature1 returns the union data inside the GridpointForecastPeriod_Temperature as a GridpointForecastPeriodTemperature1
func (t GridpointForecastPeriod_Temperature) AsGridpointForecastPeriodTemperature1() (GridpointForecastPeriodTemperature1, error) {
	var body GridpointForecastPeriodTemperature1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpointForecastPeriodTemperature1 overwrites any union data inside the GridpointForecastPeriod_Temperature as the provided GridpointForecastPeriodTemperature1
func (t *GridpointForecastPeriod_Temperature) FromGridpointForecastPeriodTemperature1(v GridpointForecastPeriodTemperature1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpointForecastPeriodTemperature1 performs a merge with any union data inside the GridpointForecastPeriod_Temperature, using the provided GridpointForecastPeriodTemperature1
func (t *GridpointForecastPeriod_Temperature) MergeGridpointForecastPeriodTemperature1(v GridpointForecastPeriodTemperature1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t GridpointForecastPeriod_Temperature) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GridpointForecastPeriod_Temperature) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the GridpointForecastPeriod_WindGust as a QuantitativeValue
func (t GridpointForecastPeriod_WindGust) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the GridpointForecastPeriod_WindGust as the provided QuantitativeValue
func (t *GridpointForecastPeriod_WindGust) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the GridpointForecastPeriod_WindGust, using the provided QuantitativeValue
func (t *GridpointForecastPeriod_WindGust) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGridpointForecastPeriodWindGust1 returns the union data inside the GridpointForecastPeriod_WindGust as a GridpointForecastPeriodWindGust1
func (t GridpointForecastPeriod_WindGust) AsGridpointForecastPeriodWindGust1() (GridpointForecastPeriodWindGust1, error) {
	var body GridpointForecastPeriodWindGust1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpointForecastPeriodWindGust1 overwrites any union data inside the GridpointForecastPeriod_WindGust as the provided GridpointForecastPeriodWindGust1
func (t *GridpointForecastPeriod_WindGust) FromGridpointForecastPeriodWindGust1(v GridpointForecastPeriodWindGust1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpointForecastPeriodWindGust1 performs a merge with any union data inside the GridpointForecastPeriod_WindGust, using the provided GridpointForecastPeriodWindGust1
func (t *GridpointForecastPeriod_WindGust) MergeGridpointForecastPeriodWindGust1(v GridpointForecastPeriodWindGust1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t GridpointForecastPeriod_WindGust) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GridpointForecastPeriod_WindGust) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsQuantitativeValue returns the union data inside the GridpointForecastPeriod_WindSpeed as a QuantitativeValue
func (t GridpointForecastPeriod_WindSpeed) AsQuantitativeValue() (QuantitativeValue, error) {
	var body QuantitativeValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQuantitativeValue overwrites any union data inside the GridpointForecastPeriod_WindSpeed as the provided QuantitativeValue
func (t *GridpointForecastPeriod_WindSpeed) FromQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQuantitativeValue performs a merge with any union data inside the GridpointForecastPeriod_WindSpeed, using the provided QuantitativeValue
func (t *GridpointForecastPeriod_WindSpeed) MergeQuantitativeValue(v QuantitativeValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsGridpointForecastPeriodWindSpeed1 returns the union data inside the GridpointForecastPeriod_WindSpeed as a GridpointForecastPeriodWindSpeed1
func (t GridpointForecastPeriod_WindSpeed) AsGridpointForecastPeriodWindSpeed1() (GridpointForecastPeriodWindSpeed1, error) {
	var body GridpointForecastPeriodWindSpeed1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGridpointForecastPeriodWindSpeed1 overwrites any union data inside the GridpointForecastPeriod_WindSpeed as the provided GridpointForecastPeriodWindSpeed1
func (t *GridpointForecastPeriod_WindSpeed) FromGridpointForecastPeriodWindSpeed1(v GridpointForecastPeriodWindSpeed1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGridpointForecastPeriodWindSpeed1 performs a merge with any union data inside the GridpointForecastPeriod_WindSpeed, using the provided GridpointForecastPeriodWindSpeed1
func (t *GridpointForecastPeriod_WindSpeed) MergeGridpointForecastPeriodWindSpeed1(v GridpointForecastPeriodWindSpeed1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t GridpointForecastPeriod_WindSpeed) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GridpointForecastPeriod_WindSpeed) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsISO8601Interval0 returns the union data inside the ISO8601Interval as a ISO8601Interval0
func (t ISO8601Interval) AsISO8601Interval0() (ISO8601Interval0, error) {
	var body ISO8601Interval0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromISO8601Interval0 overwrites any union data inside the ISO8601Interval as the provided ISO8601Interval0
func (t *ISO8601Interval) FromISO8601Interval0(v ISO8601Interval0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeISO8601Interval0 performs a merge with any union data inside the ISO8601Interval, using the provided ISO8601Interval0
func (t *ISO8601Interval) MergeISO8601Interval0(v ISO8601Interval0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsISO8601Interval1 returns the union data inside the ISO8601Interval as a ISO8601Interval1
func (t ISO8601Interval) AsISO8601Interval1() (ISO8601Interval1, error) {
	var body ISO8601Interval1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromISO8601Interval1 overwrites any union data inside the ISO8601Interval as the provided ISO8601Interval1
func (t *ISO8601Interval) FromISO8601Interval1(v ISO8601Interval1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeISO8601Interval1 performs a merge with any union data inside the ISO8601Interval, using the provided ISO8601Interval1
func (t *ISO8601Interval) MergeISO8601Interval1(v ISO8601Interval1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsISO8601Interval2 returns the union data inside the ISO8601Interval as a ISO8601Interval2
func (t ISO8601Interval) AsISO8601Interval2() (ISO8601Interval2, error) {
	var body ISO8601Interval2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromISO8601Interval2 overwrites any union data inside the ISO8601Interval as the provided ISO8601Interval2
func (t *ISO8601Interval) FromISO8601Interval2(v ISO8601Interval2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeISO8601Interval2 performs a merge with any union data inside the ISO8601Interval, using the provided ISO8601Interval2
func (t *ISO8601Interval) MergeISO8601Interval2(v ISO8601Interval2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ISO8601Interval) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ISO8601Interval) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJsonLdContext0 returns the union data inside the JsonLdContext as a JsonLdContext0
func (t JsonLdContext) AsJsonLdContext0() (JsonLdContext0, error) {
	var body JsonLdContext0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonLdContext0 overwrites any union data inside the JsonLdContext as the provided JsonLdContext0
func (t *JsonLdContext) FromJsonLdContext0(v JsonLdContext0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonLdContext0 performs a merge with any union data inside the JsonLdContext, using the provided JsonLdContext0
func (t *JsonLdContext) MergeJsonLdContext0(v JsonLdContext0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsJsonLdContext1 returns the union data inside the JsonLdContext as a JsonLdContext1
func (t JsonLdContext) AsJsonLdContext1() (JsonLdContext1, error) {
	var body JsonLdContext1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonLdContext1 overwrites any union data inside the JsonLdContext as the provided JsonLdContext1
func (t *JsonLdContext) FromJsonLdContext1(v JsonLdContext1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonLdContext1 performs a merge with any union data inside the JsonLdContext, using the provided JsonLdContext1
func (t *JsonLdContext) MergeJsonLdContext1(v JsonLdContext1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t JsonLdContext) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *JsonLdContext) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNWSForecastOfficeId returns the union data inside the NWSOfficeId as a NWSForecastOfficeId
func (t NWSOfficeId) AsNWSForecastOfficeId() (NWSForecastOfficeId, error) {
	var body NWSForecastOfficeId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNWSForecastOfficeId overwrites any union data inside the NWSOfficeId as the provided NWSForecastOfficeId
func (t *NWSOfficeId) FromNWSForecastOfficeId(v NWSForecastOfficeId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNWSForecastOfficeId performs a merge with any union data inside the NWSOfficeId, using the provided NWSForecastOfficeId
func (t *NWSOfficeId) MergeNWSForecastOfficeId(v NWSForecastOfficeId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNWSRegionalHQId returns the union data inside the NWSOfficeId as a NWSRegionalHQId
func (t NWSOfficeId) AsNWSRegionalHQId() (NWSRegionalHQId, error) {
	var body NWSRegionalHQId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNWSRegionalHQId overwrites any union data inside the NWSOfficeId as the provided NWSRegionalHQId
func (t *NWSOfficeId) FromNWSRegionalHQId(v NWSRegionalHQId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNWSRegionalHQId performs a merge with any union data inside the NWSOfficeId, using the provided NWSRegionalHQId
func (t *NWSOfficeId) MergeNWSRegionalHQId(v NWSRegionalHQId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsNWSNationalHQId returns the union data inside the NWSOfficeId as a NWSNationalHQId
func (t NWSOfficeId) AsNWSNationalHQId() (NWSNationalHQId, error) {
	var body NWSNationalHQId
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNWSNationalHQId overwrites any union data inside the NWSOfficeId as the provided NWSNationalHQId
func (t *NWSOfficeId) FromNWSNationalHQId(v NWSNationalHQId) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNWSNationalHQId performs a merge with any union data inside the NWSOfficeId, using the provided NWSNationalHQId
func (t *NWSOfficeId) MergeNWSNationalHQId(v NWSNationalHQId) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t NWSOfficeId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NWSOfficeId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelativeLocationGeoJson returns the union data inside the Point_RelativeLocation as a RelativeLocationGeoJson
func (t Point_RelativeLocation) AsRelativeLocationGeoJson() (RelativeLocationGeoJson, error) {
	var body RelativeLocationGeoJson
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationGeoJson overwrites any union data inside the Point_RelativeLocation as the provided RelativeLocationGeoJson
func (t *Point_RelativeLocation) FromRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationGeoJson performs a merge with any union data inside the Point_RelativeLocation, using the provided RelativeLocationGeoJson
func (t *Point_RelativeLocation) MergeRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRelativeLocationJsonLd returns the union data inside the Point_RelativeLocation as a RelativeLocationJsonLd
func (t Point_RelativeLocation) AsRelativeLocationJsonLd() (RelativeLocationJsonLd, error) {
	var body RelativeLocationJsonLd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationJsonLd overwrites any union data inside the Point_RelativeLocation as the provided RelativeLocationJsonLd
func (t *Point_RelativeLocation) FromRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationJsonLd performs a merge with any union data inside the Point_RelativeLocation, using the provided RelativeLocationJsonLd
func (t *Point_RelativeLocation) MergeRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Point_RelativeLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Point_RelativeLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRelativeLocationGeoJson returns the union data inside the PointJsonLd_RelativeLocation as a RelativeLocationGeoJson
func (t PointJsonLd_RelativeLocation) AsRelativeLocationGeoJson() (RelativeLocationGeoJson, error) {
	var body RelativeLocationGeoJson
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationGeoJson overwrites any union data inside the PointJsonLd_RelativeLocation as the provided RelativeLocationGeoJson
func (t *PointJsonLd_RelativeLocation) FromRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationGeoJson performs a merge with any union data inside the PointJsonLd_RelativeLocation, using the provided RelativeLocationGeoJson
func (t *PointJsonLd_RelativeLocation) MergeRelativeLocationGeoJson(v RelativeLocationGeoJson) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRelativeLocationJsonLd returns the union data inside the PointJsonLd_RelativeLocation as a RelativeLocationJsonLd
func (t PointJsonLd_RelativeLocation) AsRelativeLocationJsonLd() (RelativeLocationJsonLd, error) {
	var body RelativeLocationJsonLd
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRelativeLocationJsonLd overwrites any union data inside the PointJsonLd_RelativeLocation as the provided RelativeLocationJsonLd
func (t *PointJsonLd_RelativeLocation) FromRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRelativeLocationJsonLd performs a merge with any union data inside the PointJsonLd_RelativeLocation, using the provided RelativeLocationJsonLd
func (t *PointJsonLd_RelativeLocation) MergeRelativeLocationJsonLd(v RelativeLocationJsonLd) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t PointJsonLd_RelativeLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PointJsonLd_RelativeLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLandRegionCode returns the union data inside the RegionCode as a LandRegionCode
func (t RegionCode) AsLandRegionCode() (LandRegionCode, error) {
	var body LandRegionCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLandRegionCode overwrites any union data inside the RegionCode as the provided LandRegionCode
func (t *RegionCode) FromLandRegionCode(v LandRegionCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLandRegionCode performs a merge with any union data inside the RegionCode, using the provided LandRegionCode
func (t *RegionCode) MergeLandRegionCode(v LandRegionCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMarineRegionCode returns the union data inside the RegionCode as a MarineRegionCode
func (t RegionCode) AsMarineRegionCode() (MarineRegionCode, error) {
	var body MarineRegionCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarineRegionCode overwrites any union data inside the RegionCode as the provided MarineRegionCode
func (t *RegionCode) FromMarineRegionCode(v MarineRegionCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarineRegionCode performs a merge with any union data inside the RegionCode, using the provided MarineRegionCode
func (t *RegionCode) MergeMarineRegionCode(v MarineRegionCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RegionCode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RegionCode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStateTerritoryCode returns the union data inside the Zone_State as a StateTerritoryCode
func (t Zone_State) AsStateTerritoryCode() (StateTerritoryCode, error) {
	var body StateTerritoryCode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStateTerritoryCode overwrites any union data inside the Zone_State as the provided StateTerritoryCode
func (t *Zone_State) FromStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStateTerritoryCode performs a merge with any union data inside the Zone_State, using the provided StateTerritoryCode
func (t *Zone_State) MergeStateTerritoryCode(v StateTerritoryCode) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsZoneState1 returns the union data inside the Zone_State as a ZoneState1
func (t Zone_State) AsZoneState1() (ZoneState1, error) {
	var body ZoneState1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromZoneState1 overwrites any union data inside the Zone_State as the provided ZoneState1
func (t *Zone_State) FromZoneState1(v ZoneState1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeZoneState1 performs a merge with any union data inside the Zone_State, using the provided ZoneState1
func (t *Zone_State) MergeZoneState1(v ZoneState1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Zone_State) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Zone_State) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AlertsQuery request
	AlertsQuery(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActive request
	AlertsActive(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveArea request
	AlertsActiveArea(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveCount request
	AlertsActiveCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveRegion request
	AlertsActiveRegion(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsActiveZone request
	AlertsActiveZone(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsTypes request
	AlertsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AlertsSingle request
	AlertsSingle(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cwsu request
	Cwsu(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cwas request
	Cwas(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Cwa request
	Cwa(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SigmetQuery request
	SigmetQuery(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SigmetsByATSU request
	SigmetsByATSU(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SigmetsByATSUByDate request
	SigmetsByATSUByDate(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Sigmet request
	Sigmet(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Glossary request
	Glossary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gridpoint request
	Gridpoint(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GridpointForecast request
	GridpointForecast(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GridpointForecastHourly request
	GridpointForecastHourly(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GridpointStations request
	GridpointStations(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IconsSummary request
	IconsSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Icons request
	Icons(ctx context.Context, set string, timeOfDay string, first string, params *IconsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IconsDualCondition request
	IconsDualCondition(ctx context.Context, set string, timeOfDay string, first string, second string, params *IconsDualConditionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Office request
	Office(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OfficeHeadlines request
	OfficeHeadlines(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OfficeHeadline request
	OfficeHeadline(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, headlineId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Point request
	Point(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PointStations request
	PointStations(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsQuery request
	ProductsQuery(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductLocations request
	ProductLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LocationProducts request
	LocationProducts(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductTypes request
	ProductTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsType request
	ProductsType(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsTypeLocations request
	ProductsTypeLocations(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProductsTypeLocation request
	ProductsTypeLocation(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Product request
	Product(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarProfiler request
	RadarProfiler(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarQueue request
	RadarQueue(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarServers request
	RadarServers(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarServer request
	RadarServer(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarStations request
	RadarStations(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarStation request
	RadarStation(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RadarStationAlarms request
	RadarStationAlarms(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObsStations request
	ObsStations(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObsStation request
	ObsStation(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StationObservationList request
	StationObservationList(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StationObservationLatest request
	StationObservationLatest(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StationObservationTime request
	StationObservationTime(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Tafs request
	Tafs(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Taf request
	Taf(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SatelliteThumbnails request
	SatelliteThumbnails(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneList request
	ZoneList(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneObs request
	ZoneObs(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneStations request
	ZoneStations(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneListType request
	ZoneListType(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Zone request
	Zone(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZoneForecast request
	ZoneForecast(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AlertsQuery(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActive(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveArea(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveAreaRequest(c.Server, area)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveCount(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveCountRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveRegion(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveRegionRequest(c.Server, region)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsActiveZone(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsActiveZoneRequest(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AlertsSingle(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAlertsSingleRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cwsu(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCwsuRequest(c.Server, cwsuId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cwas(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCwasRequest(c.Server, cwsuId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Cwa(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCwaRequest(c.Server, cwsuId, date, sequence)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SigmetQuery(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SigmetsByATSU(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetsByATSURequest(c.Server, atsu)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SigmetsByATSUByDate(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetsByATSUByDateRequest(c.Server, atsu, date)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Sigmet(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSigmetRequest(c.Server, atsu, date, time)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Glossary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGlossaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gridpoint(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointRequest(c.Server, wfo, x, y)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GridpointForecast(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointForecastRequest(c.Server, wfo, x, y, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GridpointForecastHourly(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointForecastHourlyRequest(c.Server, wfo, x, y, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GridpointStations(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGridpointStationsRequest(c.Server, wfo, x, y, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IconsSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIconsSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Icons(ctx context.Context, set string, timeOfDay string, first string, params *IconsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIconsRequest(c.Server, set, timeOfDay, first, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IconsDualCondition(ctx context.Context, set string, timeOfDay string, first string, second string, params *IconsDualConditionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIconsDualConditionRequest(c.Server, set, timeOfDay, first, second, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Office(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficeRequest(c.Server, nWSOfficeIdReference)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OfficeHeadlines(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficeHeadlinesRequest(c.Server, nWSOfficeIdReference)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OfficeHeadline(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, headlineId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOfficeHeadlineRequest(c.Server, nWSOfficeIdReference, headlineId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Point(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPointRequest(c.Server, point)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PointStations(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPointStationsRequest(c.Server, point)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsQuery(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsQueryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductLocations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductLocationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LocationProducts(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLocationProductsRequest(c.Server, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsType(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsTypeRequest(c.Server, typeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsTypeLocations(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsTypeLocationsRequest(c.Server, typeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProductsTypeLocation(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductsTypeLocationRequest(c.Server, typeId, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Product(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProductRequest(c.Server, productId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarProfiler(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarProfilerRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarQueue(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarQueueRequest(c.Server, host, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarServers(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarServersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarServer(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarServerRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarStations(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarStationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarStation(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarStationRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RadarStationAlarms(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRadarStationAlarmsRequest(c.Server, stationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObsStations(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObsStationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObsStation(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObsStationRequest(c.Server, stationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StationObservationList(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStationObservationListRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StationObservationLatest(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStationObservationLatestRequest(c.Server, stationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StationObservationTime(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStationObservationTimeRequest(c.Server, stationId, time)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Tafs(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTafsRequest(c.Server, stationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Taf(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTafRequest(c.Server, stationId, date, time)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SatelliteThumbnails(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSatelliteThumbnailsRequest(c.Server, area)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneList(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneObs(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneObsRequest(c.Server, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneStations(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneStationsRequest(c.Server, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneListType(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneListTypeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Zone(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneRequest(c.Server, pType, zoneId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZoneForecast(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZoneForecastRequest(c.Server, pType, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAlertsQueryRequest generates requests for AlertsQuery
func NewAlertsQueryRequest(server string, params *AlertsQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Active != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "active", runtime.ParamLocationQuery, *params.Active); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MessageType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "message_type", runtime.ParamLocationQuery, *params.MessageType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Event != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Code != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Area != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Point != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RegionType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_type", runtime.ParamLocationQuery, *params.RegionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Zone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "zone", runtime.ParamLocationQuery, *params.Zone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Urgency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "urgency", runtime.ParamLocationQuery, *params.Urgency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Certainty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certainty", runtime.ParamLocationQuery, *params.Certainty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveRequest generates requests for AlertsActive
func NewAlertsActiveRequest(server string, params *AlertsActiveParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MessageType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "message_type", runtime.ParamLocationQuery, *params.MessageType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Event != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Code != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Area != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Point != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RegionType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region_type", runtime.ParamLocationQuery, *params.RegionType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Zone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "zone", runtime.ParamLocationQuery, *params.Zone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Urgency != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "urgency", runtime.ParamLocationQuery, *params.Urgency); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Severity != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "severity", runtime.ParamLocationQuery, *params.Severity); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Certainty != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "certainty", runtime.ParamLocationQuery, *params.Certainty); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveAreaRequest generates requests for AlertsActiveArea
func NewAlertsActiveAreaRequest(server string, area AreaCode) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "area", runtime.ParamLocationPath, area)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/area/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveCountRequest generates requests for AlertsActiveCount
func NewAlertsActiveCountRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveRegionRequest generates requests for AlertsActiveRegion
func NewAlertsActiveRegionRequest(server string, region MarineRegionCode) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "region", runtime.ParamLocationPath, region)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/region/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsActiveZoneRequest generates requests for AlertsActiveZone
func NewAlertsActiveZoneRequest(server string, zoneId NWSZoneId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/active/zone/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsTypesRequest generates requests for AlertsTypes
func NewAlertsTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAlertsSingleRequest generates requests for AlertsSingle
func NewAlertsSingleRequest(server string, id AlertId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCwsuRequest generates requests for Cwsu
func NewCwsuRequest(server string, cwsuId NWSCenterWeatherServiceUnitId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, cwsuId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/cwsus/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCwasRequest generates requests for Cwas
func NewCwasRequest(server string, cwsuId NWSCenterWeatherServiceUnitId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, cwsuId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/cwsus/%s/cwas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCwaRequest generates requests for Cwa
func NewCwaRequest(server string, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, cwsuId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sequence", runtime.ParamLocationPath, sequence)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/cwsus/%s/cwas/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetQueryRequest generates requests for SigmetQuery
func NewSigmetQueryRequest(server string, params *SigmetQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Date != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date", runtime.ParamLocationQuery, *params.Date); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Atsu != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "atsu", runtime.ParamLocationQuery, *params.Atsu); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sequence != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sequence", runtime.ParamLocationQuery, *params.Sequence); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetsByATSURequest generates requests for SigmetsByATSU
func NewSigmetsByATSURequest(server string, atsu ATSUIdentifier) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "atsu", runtime.ParamLocationPath, atsu)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetsByATSUByDateRequest generates requests for SigmetsByATSUByDate
func NewSigmetsByATSUByDateRequest(server string, atsu ATSUIdentifier, date Date) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "atsu", runtime.ParamLocationPath, atsu)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSigmetRequest generates requests for Sigmet
func NewSigmetRequest(server string, atsu ATSUIdentifier, date Date, time Time) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "atsu", runtime.ParamLocationPath, atsu)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "time", runtime.ParamLocationPath, time)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aviation/sigmets/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGlossaryRequest generates requests for Glossary
func NewGlossaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/glossary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGridpointRequest generates requests for Gridpoint
func NewGridpointRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGridpointForecastRequest generates requests for GridpointForecast
func NewGridpointForecastRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s/forecast", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Units != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, *params.Units); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.FeatureFlags != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Feature-Flags", headerParam0)
	}

	return req, nil
}

// NewGridpointForecastHourlyRequest generates requests for GridpointForecastHourly
func NewGridpointForecastHourlyRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s/forecast/hourly", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Units != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "units", runtime.ParamLocationQuery, *params.Units); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.FeatureFlags != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, *params.FeatureFlags)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Feature-Flags", headerParam0)
	}

	return req, nil
}

// NewGridpointStationsRequest generates requests for GridpointStations
func NewGridpointStationsRequest(server string, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "wfo", runtime.ParamLocationPath, wfo)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "x", runtime.ParamLocationPath, x)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "y", runtime.ParamLocationPath, y)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gridpoints/%s/%s,%s/stations", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIconsSummaryRequest generates requests for IconsSummary
func NewIconsSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/icons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIconsRequest generates requests for Icons
func NewIconsRequest(server string, set string, timeOfDay string, first string, params *IconsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "set", runtime.ParamLocationPath, set)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "timeOfDay", runtime.ParamLocationPath, timeOfDay)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "first", runtime.ParamLocationPath, first)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/icons/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fontsize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fontsize", runtime.ParamLocationQuery, *params.Fontsize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIconsDualConditionRequest generates requests for IconsDualCondition
func NewIconsDualConditionRequest(server string, set string, timeOfDay string, first string, second string, params *IconsDualConditionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "set", runtime.ParamLocationPath, set)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "timeOfDay", runtime.ParamLocationPath, timeOfDay)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "first", runtime.ParamLocationPath, first)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "second", runtime.ParamLocationPath, second)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/icons/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Size != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Fontsize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fontsize", runtime.ParamLocationQuery, *params.Fontsize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfficeRequest generates requests for Office
func NewOfficeRequest(server string, nWSOfficeIdReference NWSOfficeIdReference) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "officeId", runtime.ParamLocationPath, nWSOfficeIdReference)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offices/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfficeHeadlinesRequest generates requests for OfficeHeadlines
func NewOfficeHeadlinesRequest(server string, nWSOfficeIdReference NWSOfficeIdReference) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "officeId", runtime.ParamLocationPath, nWSOfficeIdReference)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offices/%s/headlines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOfficeHeadlineRequest generates requests for OfficeHeadline
func NewOfficeHeadlineRequest(server string, nWSOfficeIdReference NWSOfficeIdReference, headlineId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "officeId", runtime.ParamLocationPath, nWSOfficeIdReference)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "headlineId", runtime.ParamLocationPath, headlineId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/offices/%s/headlines/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPointRequest generates requests for Point
func NewPointRequest(server string, point PathPoint) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "point", runtime.ParamLocationPath, point)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/points/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPointStationsRequest generates requests for PointStations
func NewPointStationsRequest(server string, point PathPoint) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "point", runtime.ParamLocationPath, point)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/points/%s/stations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsQueryRequest generates requests for ProductsQuery
func NewProductsQueryRequest(server string, params *ProductsQueryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Office != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "office", runtime.ParamLocationQuery, *params.Office); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Wmoid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wmoid", runtime.ParamLocationQuery, *params.Wmoid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductLocationsRequest generates requests for ProductLocations
func NewProductLocationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLocationProductsRequest generates requests for LocationProducts
func NewLocationProductsRequest(server string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "locationId", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/locations/%s/types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductTypesRequest generates requests for ProductTypes
func NewProductTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsTypeRequest generates requests for ProductsType
func NewProductsTypeRequest(server string, typeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsTypeLocationsRequest generates requests for ProductsTypeLocations
func NewProductsTypeLocationsRequest(server string, typeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s/locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductsTypeLocationRequest generates requests for ProductsTypeLocation
func NewProductsTypeLocationRequest(server string, typeId string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "typeId", runtime.ParamLocationPath, typeId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "locationId", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/types/%s/locations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProductRequest generates requests for Product
func NewProductRequest(server string, productId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "productId", runtime.ParamLocationPath, productId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarProfilerRequest generates requests for RadarProfiler
func NewRadarProfilerRequest(server string, stationId string, params *RadarProfilerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/profilers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Time != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Interval != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval", runtime.ParamLocationQuery, *params.Interval); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarQueueRequest generates requests for RadarQueue
func NewRadarQueueRequest(server string, host string, params *RadarQueueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "host", runtime.ParamLocationPath, host)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/queues/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Arrived != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrived", runtime.ParamLocationQuery, *params.Arrived); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Published != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published", runtime.ParamLocationQuery, *params.Published); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Station != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "station", runtime.ParamLocationQuery, *params.Station); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Feed != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feed", runtime.ParamLocationQuery, *params.Feed); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resolution != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarServersRequest generates requests for RadarServers
func NewRadarServersRequest(server string, params *RadarServersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/servers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ReportingHost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarServerRequest generates requests for RadarServer
func NewRadarServerRequest(server string, id string, params *RadarServerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/servers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ReportingHost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarStationsRequest generates requests for RadarStations
func NewRadarStationsRequest(server string, params *RadarStationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.StationType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "stationType", runtime.ParamLocationQuery, *params.StationType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ReportingHost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Host != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarStationRequest generates requests for RadarStation
func NewRadarStationRequest(server string, stationId string, params *RadarStationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/stations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ReportingHost != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportingHost", runtime.ParamLocationQuery, *params.ReportingHost); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Host != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "host", runtime.ParamLocationQuery, *params.Host); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRadarStationAlarmsRequest generates requests for RadarStationAlarms
func NewRadarStationAlarmsRequest(server string, stationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/radar/stations/%s/alarms", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObsStationsRequest generates requests for ObsStations
func NewObsStationsRequest(server string, params *ObsStationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObsStationRequest generates requests for ObsStation
func NewObsStationRequest(server string, stationId ObservationStationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStationObservationListRequest generates requests for StationObservationList
func NewStationObservationListRequest(server string, stationId ObservationStationId, params *StationObservationListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/observations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStationObservationLatestRequest generates requests for StationObservationLatest
func NewStationObservationLatestRequest(server string, stationId ObservationStationId, params *StationObservationLatestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/observations/latest", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.RequireQc != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "require_qc", runtime.ParamLocationQuery, *params.RequireQc); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStationObservationTimeRequest generates requests for StationObservationTime
func NewStationObservationTimeRequest(server string, stationId ObservationStationId, time time.Time) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "time", runtime.ParamLocationPath, time)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/observations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTafsRequest generates requests for Tafs
func NewTafsRequest(server string, stationId ObservationStationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/tafs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTafRequest generates requests for Taf
func NewTafRequest(server string, stationId ObservationStationId, date Date, time Time) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stationId", runtime.ParamLocationPath, stationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "date", runtime.ParamLocationPath, date)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "time", runtime.ParamLocationPath, time)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stations/%s/tafs/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSatelliteThumbnailsRequest generates requests for SatelliteThumbnails
func NewSatelliteThumbnailsRequest(server string, area string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "area", runtime.ParamLocationPath, area)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/satellite/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneListRequest generates requests for ZoneList
func NewZoneListRequest(server string, params *ZoneListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Area != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Point != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeGeometry != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_geometry", runtime.ParamLocationQuery, *params.IncludeGeometry); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneObsRequest generates requests for ZoneObs
func NewZoneObsRequest(server string, zoneId NWSZoneId, params *ZoneObsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/forecast/%s/observations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneStationsRequest generates requests for ZoneStations
func NewZoneStationsRequest(server string, zoneId NWSZoneId, params *ZoneStationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/forecast/%s/stations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneListTypeRequest generates requests for ZoneListType
func NewZoneListTypeRequest(server string, pType NWSZoneType, params *ZoneListTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Id != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Area != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "area", runtime.ParamLocationQuery, *params.Area); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Region != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Point != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "point", runtime.ParamLocationQuery, *params.Point); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IncludeGeometry != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_geometry", runtime.ParamLocationQuery, *params.IncludeGeometry); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneRequest generates requests for Zone
func NewZoneRequest(server string, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZoneForecastRequest generates requests for ZoneForecast
func NewZoneForecastRequest(server string, pType string, zoneId NWSZoneId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zones/%s/%s/forecast", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AlertsQuery request
	AlertsQueryWithResponse(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*AlertsQueryResponse, error)

	// AlertsActive request
	AlertsActiveWithResponse(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*AlertsActiveResponse, error)

	// AlertsActiveArea request
	AlertsActiveAreaWithResponse(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*AlertsActiveAreaResponse, error)

	// AlertsActiveCount request
	AlertsActiveCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsActiveCountResponse, error)

	// AlertsActiveRegion request
	AlertsActiveRegionWithResponse(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*AlertsActiveRegionResponse, error)

	// AlertsActiveZone request
	AlertsActiveZoneWithResponse(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*AlertsActiveZoneResponse, error)

	// AlertsTypes request
	AlertsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsTypesResponse, error)

	// AlertsSingle request
	AlertsSingleWithResponse(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*AlertsSingleResponse, error)

	// Cwsu request
	CwsuWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwsuResponse, error)

	// Cwas request
	CwasWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwasResponse, error)

	// Cwa request
	CwaWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*CwaResponse, error)

	// SigmetQuery request
	SigmetQueryWithResponse(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*SigmetQueryResponse, error)

	// SigmetsByATSU request
	SigmetsByATSUWithResponse(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*SigmetsByATSUResponse, error)

	// SigmetsByATSUByDate request
	SigmetsByATSUByDateWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*SigmetsByATSUByDateResponse, error)

	// Sigmet request
	SigmetWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*SigmetResponse, error)

	// Glossary request
	GlossaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlossaryResponse, error)

	// Gridpoint request
	GridpointWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*GridpointResponse, error)

	// GridpointForecast request
	GridpointForecastWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*GridpointForecastResponse, error)

	// GridpointForecastHourly request
	GridpointForecastHourlyWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*GridpointForecastHourlyResponse, error)

	// GridpointStations request
	GridpointStationsWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*GridpointStationsResponse, error)

	// IconsSummary request
	IconsSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IconsSummaryResponse, error)

	// Icons request
	IconsWithResponse(ctx context.Context, set string, timeOfDay string, first string, params *IconsParams, reqEditors ...RequestEditorFn) (*IconsResponse, error)

	// IconsDualCondition request
	IconsDualConditionWithResponse(ctx context.Context, set string, timeOfDay string, first string, second string, params *IconsDualConditionParams, reqEditors ...RequestEditorFn) (*IconsDualConditionResponse, error)

	// Office request
	OfficeWithResponse(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*OfficeResponse, error)

	// OfficeHeadlines request
	OfficeHeadlinesWithResponse(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*OfficeHeadlinesResponse, error)

	// OfficeHeadline request
	OfficeHeadlineWithResponse(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, headlineId string, reqEditors ...RequestEditorFn) (*OfficeHeadlineResponse, error)

	// Point request
	PointWithResponse(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*PointResponse, error)

	// PointStations request
	PointStationsWithResponse(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*PointStationsResponse, error)

	// ProductsQuery request
	ProductsQueryWithResponse(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*ProductsQueryResponse, error)

	// ProductLocations request
	ProductLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductLocationsResponse, error)

	// LocationProducts request
	LocationProductsWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*LocationProductsResponse, error)

	// ProductTypes request
	ProductTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductTypesResponse, error)

	// ProductsType request
	ProductsTypeWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeResponse, error)

	// ProductsTypeLocations request
	ProductsTypeLocationsWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationsResponse, error)

	// ProductsTypeLocation request
	ProductsTypeLocationWithResponse(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationResponse, error)

	// Product request
	ProductWithResponse(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*ProductResponse, error)

	// RadarProfiler request
	RadarProfilerWithResponse(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*RadarProfilerResponse, error)

	// RadarQueue request
	RadarQueueWithResponse(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*RadarQueueResponse, error)

	// RadarServers request
	RadarServersWithResponse(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*RadarServersResponse, error)

	// RadarServer request
	RadarServerWithResponse(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*RadarServerResponse, error)

	// RadarStations request
	RadarStationsWithResponse(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*RadarStationsResponse, error)

	// RadarStation request
	RadarStationWithResponse(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*RadarStationResponse, error)

	// RadarStationAlarms request
	RadarStationAlarmsWithResponse(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*RadarStationAlarmsResponse, error)

	// ObsStations request
	ObsStationsWithResponse(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*ObsStationsResponse, error)

	// ObsStation request
	ObsStationWithResponse(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*ObsStationResponse, error)

	// StationObservationList request
	StationObservationListWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*StationObservationListResponse, error)

	// StationObservationLatest request
	StationObservationLatestWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*StationObservationLatestResponse, error)

	// StationObservationTime request
	StationObservationTimeWithResponse(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*StationObservationTimeResponse, error)

	// Tafs request
	TafsWithResponse(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*TafsResponse, error)

	// Taf request
	TafWithResponse(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*TafResponse, error)

	// SatelliteThumbnails request
	SatelliteThumbnailsWithResponse(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*SatelliteThumbnailsResponse, error)

	// ZoneList request
	ZoneListWithResponse(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*ZoneListResponse, error)

	// ZoneObs request
	ZoneObsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*ZoneObsResponse, error)

	// ZoneStations request
	ZoneStationsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*ZoneStationsResponse, error)

	// ZoneListType request
	ZoneListTypeWithResponse(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*ZoneListTypeResponse, error)

	// Zone request
	ZoneWithResponse(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*ZoneResponse, error)

	// ZoneForecast request
	ZoneForecastWithResponse(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*ZoneForecastResponse, error)
}

type AlertsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsActiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveAreaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsActiveAreaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveAreaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveCountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsActiveCountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveCountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsActiveRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsActiveZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsActiveZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsActiveZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AlertsSingleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r AlertsSingleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AlertsSingleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CwsuResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CwsuResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CwsuResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CwasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CwasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CwasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CwaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r CwaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CwaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SigmetQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetsByATSUResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SigmetsByATSUResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetsByATSUResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetsByATSUByDateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SigmetsByATSUByDateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetsByATSUByDateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SigmetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SigmetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SigmetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GlossaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GlossaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GlossaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GridpointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointForecastResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GridpointForecastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointForecastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointForecastHourlyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GridpointForecastHourlyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointForecastHourlyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GridpointStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r GridpointStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GridpointStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IconsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r IconsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IconsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IconsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r IconsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IconsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IconsDualConditionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r IconsDualConditionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IconsDualConditionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r OfficeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficeHeadlinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r OfficeHeadlinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficeHeadlinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OfficeHeadlineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r OfficeHeadlineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OfficeHeadlineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PointStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r PointStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PointStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductsQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LocationProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r LocationProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LocationProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductsTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsTypeLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductsTypeLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsTypeLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductsTypeLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductsTypeLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductsTypeLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarProfilerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarProfilerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarProfilerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarServersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarServersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarServersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarStationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarStationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarStationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RadarStationAlarmsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r RadarStationAlarmsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RadarStationAlarmsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObsStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ObsStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObsStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObsStationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ObsStationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObsStationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StationObservationListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r StationObservationListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StationObservationListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StationObservationLatestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r StationObservationLatestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StationObservationLatestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StationObservationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r StationObservationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StationObservationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TafsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r TafsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TafsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TafResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r TafResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TafResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SatelliteThumbnailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r SatelliteThumbnailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SatelliteThumbnailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ZoneListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneObsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ZoneObsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneObsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneStationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ZoneStationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneStationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneListTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ZoneListTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneListTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ZoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZoneForecastResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *ProblemDetail
}

// Status returns HTTPResponse.Status
func (r ZoneForecastResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZoneForecastResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AlertsQueryWithResponse request returning *AlertsQueryResponse
func (c *ClientWithResponses) AlertsQueryWithResponse(ctx context.Context, params *AlertsQueryParams, reqEditors ...RequestEditorFn) (*AlertsQueryResponse, error) {
	rsp, err := c.AlertsQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsQueryResponse(rsp)
}

// AlertsActiveWithResponse request returning *AlertsActiveResponse
func (c *ClientWithResponses) AlertsActiveWithResponse(ctx context.Context, params *AlertsActiveParams, reqEditors ...RequestEditorFn) (*AlertsActiveResponse, error) {
	rsp, err := c.AlertsActive(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveResponse(rsp)
}

// AlertsActiveAreaWithResponse request returning *AlertsActiveAreaResponse
func (c *ClientWithResponses) AlertsActiveAreaWithResponse(ctx context.Context, area AreaCode, reqEditors ...RequestEditorFn) (*AlertsActiveAreaResponse, error) {
	rsp, err := c.AlertsActiveArea(ctx, area, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveAreaResponse(rsp)
}

// AlertsActiveCountWithResponse request returning *AlertsActiveCountResponse
func (c *ClientWithResponses) AlertsActiveCountWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsActiveCountResponse, error) {
	rsp, err := c.AlertsActiveCount(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveCountResponse(rsp)
}

// AlertsActiveRegionWithResponse request returning *AlertsActiveRegionResponse
func (c *ClientWithResponses) AlertsActiveRegionWithResponse(ctx context.Context, region MarineRegionCode, reqEditors ...RequestEditorFn) (*AlertsActiveRegionResponse, error) {
	rsp, err := c.AlertsActiveRegion(ctx, region, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveRegionResponse(rsp)
}

// AlertsActiveZoneWithResponse request returning *AlertsActiveZoneResponse
func (c *ClientWithResponses) AlertsActiveZoneWithResponse(ctx context.Context, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*AlertsActiveZoneResponse, error) {
	rsp, err := c.AlertsActiveZone(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsActiveZoneResponse(rsp)
}

// AlertsTypesWithResponse request returning *AlertsTypesResponse
func (c *ClientWithResponses) AlertsTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AlertsTypesResponse, error) {
	rsp, err := c.AlertsTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsTypesResponse(rsp)
}

// AlertsSingleWithResponse request returning *AlertsSingleResponse
func (c *ClientWithResponses) AlertsSingleWithResponse(ctx context.Context, id AlertId, reqEditors ...RequestEditorFn) (*AlertsSingleResponse, error) {
	rsp, err := c.AlertsSingle(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAlertsSingleResponse(rsp)
}

// CwsuWithResponse request returning *CwsuResponse
func (c *ClientWithResponses) CwsuWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwsuResponse, error) {
	rsp, err := c.Cwsu(ctx, cwsuId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCwsuResponse(rsp)
}

// CwasWithResponse request returning *CwasResponse
func (c *ClientWithResponses) CwasWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, reqEditors ...RequestEditorFn) (*CwasResponse, error) {
	rsp, err := c.Cwas(ctx, cwsuId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCwasResponse(rsp)
}

// CwaWithResponse request returning *CwaResponse
func (c *ClientWithResponses) CwaWithResponse(ctx context.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int, reqEditors ...RequestEditorFn) (*CwaResponse, error) {
	rsp, err := c.Cwa(ctx, cwsuId, date, sequence, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCwaResponse(rsp)
}

// SigmetQueryWithResponse request returning *SigmetQueryResponse
func (c *ClientWithResponses) SigmetQueryWithResponse(ctx context.Context, params *SigmetQueryParams, reqEditors ...RequestEditorFn) (*SigmetQueryResponse, error) {
	rsp, err := c.SigmetQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetQueryResponse(rsp)
}

// SigmetsByATSUWithResponse request returning *SigmetsByATSUResponse
func (c *ClientWithResponses) SigmetsByATSUWithResponse(ctx context.Context, atsu ATSUIdentifier, reqEditors ...RequestEditorFn) (*SigmetsByATSUResponse, error) {
	rsp, err := c.SigmetsByATSU(ctx, atsu, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetsByATSUResponse(rsp)
}

// SigmetsByATSUByDateWithResponse request returning *SigmetsByATSUByDateResponse
func (c *ClientWithResponses) SigmetsByATSUByDateWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, reqEditors ...RequestEditorFn) (*SigmetsByATSUByDateResponse, error) {
	rsp, err := c.SigmetsByATSUByDate(ctx, atsu, date, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetsByATSUByDateResponse(rsp)
}

// SigmetWithResponse request returning *SigmetResponse
func (c *ClientWithResponses) SigmetWithResponse(ctx context.Context, atsu ATSUIdentifier, date Date, time Time, reqEditors ...RequestEditorFn) (*SigmetResponse, error) {
	rsp, err := c.Sigmet(ctx, atsu, date, time, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSigmetResponse(rsp)
}

// GlossaryWithResponse request returning *GlossaryResponse
func (c *ClientWithResponses) GlossaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GlossaryResponse, error) {
	rsp, err := c.Glossary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGlossaryResponse(rsp)
}

// GridpointWithResponse request returning *GridpointResponse
func (c *ClientWithResponses) GridpointWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, reqEditors ...RequestEditorFn) (*GridpointResponse, error) {
	rsp, err := c.Gridpoint(ctx, wfo, x, y, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointResponse(rsp)
}

// GridpointForecastWithResponse request returning *GridpointForecastResponse
func (c *ClientWithResponses) GridpointForecastWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastParams, reqEditors ...RequestEditorFn) (*GridpointForecastResponse, error) {
	rsp, err := c.GridpointForecast(ctx, wfo, x, y, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointForecastResponse(rsp)
}

// GridpointForecastHourlyWithResponse request returning *GridpointForecastHourlyResponse
func (c *ClientWithResponses) GridpointForecastHourlyWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointForecastHourlyParams, reqEditors ...RequestEditorFn) (*GridpointForecastHourlyResponse, error) {
	rsp, err := c.GridpointForecastHourly(ctx, wfo, x, y, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointForecastHourlyResponse(rsp)
}

// GridpointStationsWithResponse request returning *GridpointStationsResponse
func (c *ClientWithResponses) GridpointStationsWithResponse(ctx context.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params *GridpointStationsParams, reqEditors ...RequestEditorFn) (*GridpointStationsResponse, error) {
	rsp, err := c.GridpointStations(ctx, wfo, x, y, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGridpointStationsResponse(rsp)
}

// IconsSummaryWithResponse request returning *IconsSummaryResponse
func (c *ClientWithResponses) IconsSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*IconsSummaryResponse, error) {
	rsp, err := c.IconsSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIconsSummaryResponse(rsp)
}

// IconsWithResponse request returning *IconsResponse
func (c *ClientWithResponses) IconsWithResponse(ctx context.Context, set string, timeOfDay string, first string, params *IconsParams, reqEditors ...RequestEditorFn) (*IconsResponse, error) {
	rsp, err := c.Icons(ctx, set, timeOfDay, first, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIconsResponse(rsp)
}

// IconsDualConditionWithResponse request returning *IconsDualConditionResponse
func (c *ClientWithResponses) IconsDualConditionWithResponse(ctx context.Context, set string, timeOfDay string, first string, second string, params *IconsDualConditionParams, reqEditors ...RequestEditorFn) (*IconsDualConditionResponse, error) {
	rsp, err := c.IconsDualCondition(ctx, set, timeOfDay, first, second, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIconsDualConditionResponse(rsp)
}

// OfficeWithResponse request returning *OfficeResponse
func (c *ClientWithResponses) OfficeWithResponse(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*OfficeResponse, error) {
	rsp, err := c.Office(ctx, nWSOfficeIdReference, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficeResponse(rsp)
}

// OfficeHeadlinesWithResponse request returning *OfficeHeadlinesResponse
func (c *ClientWithResponses) OfficeHeadlinesWithResponse(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, reqEditors ...RequestEditorFn) (*OfficeHeadlinesResponse, error) {
	rsp, err := c.OfficeHeadlines(ctx, nWSOfficeIdReference, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficeHeadlinesResponse(rsp)
}

// OfficeHeadlineWithResponse request returning *OfficeHeadlineResponse
func (c *ClientWithResponses) OfficeHeadlineWithResponse(ctx context.Context, nWSOfficeIdReference NWSOfficeIdReference, headlineId string, reqEditors ...RequestEditorFn) (*OfficeHeadlineResponse, error) {
	rsp, err := c.OfficeHeadline(ctx, nWSOfficeIdReference, headlineId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOfficeHeadlineResponse(rsp)
}

// PointWithResponse request returning *PointResponse
func (c *ClientWithResponses) PointWithResponse(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*PointResponse, error) {
	rsp, err := c.Point(ctx, point, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePointResponse(rsp)
}

// PointStationsWithResponse request returning *PointStationsResponse
func (c *ClientWithResponses) PointStationsWithResponse(ctx context.Context, point PathPoint, reqEditors ...RequestEditorFn) (*PointStationsResponse, error) {
	rsp, err := c.PointStations(ctx, point, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePointStationsResponse(rsp)
}

// ProductsQueryWithResponse request returning *ProductsQueryResponse
func (c *ClientWithResponses) ProductsQueryWithResponse(ctx context.Context, params *ProductsQueryParams, reqEditors ...RequestEditorFn) (*ProductsQueryResponse, error) {
	rsp, err := c.ProductsQuery(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsQueryResponse(rsp)
}

// ProductLocationsWithResponse request returning *ProductLocationsResponse
func (c *ClientWithResponses) ProductLocationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductLocationsResponse, error) {
	rsp, err := c.ProductLocations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductLocationsResponse(rsp)
}

// LocationProductsWithResponse request returning *LocationProductsResponse
func (c *ClientWithResponses) LocationProductsWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*LocationProductsResponse, error) {
	rsp, err := c.LocationProducts(ctx, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLocationProductsResponse(rsp)
}

// ProductTypesWithResponse request returning *ProductTypesResponse
func (c *ClientWithResponses) ProductTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProductTypesResponse, error) {
	rsp, err := c.ProductTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductTypesResponse(rsp)
}

// ProductsTypeWithResponse request returning *ProductsTypeResponse
func (c *ClientWithResponses) ProductsTypeWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeResponse, error) {
	rsp, err := c.ProductsType(ctx, typeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsTypeResponse(rsp)
}

// ProductsTypeLocationsWithResponse request returning *ProductsTypeLocationsResponse
func (c *ClientWithResponses) ProductsTypeLocationsWithResponse(ctx context.Context, typeId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationsResponse, error) {
	rsp, err := c.ProductsTypeLocations(ctx, typeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsTypeLocationsResponse(rsp)
}

// ProductsTypeLocationWithResponse request returning *ProductsTypeLocationResponse
func (c *ClientWithResponses) ProductsTypeLocationWithResponse(ctx context.Context, typeId string, locationId string, reqEditors ...RequestEditorFn) (*ProductsTypeLocationResponse, error) {
	rsp, err := c.ProductsTypeLocation(ctx, typeId, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductsTypeLocationResponse(rsp)
}

// ProductWithResponse request returning *ProductResponse
func (c *ClientWithResponses) ProductWithResponse(ctx context.Context, productId string, reqEditors ...RequestEditorFn) (*ProductResponse, error) {
	rsp, err := c.Product(ctx, productId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProductResponse(rsp)
}

// RadarProfilerWithResponse request returning *RadarProfilerResponse
func (c *ClientWithResponses) RadarProfilerWithResponse(ctx context.Context, stationId string, params *RadarProfilerParams, reqEditors ...RequestEditorFn) (*RadarProfilerResponse, error) {
	rsp, err := c.RadarProfiler(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarProfilerResponse(rsp)
}

// RadarQueueWithResponse request returning *RadarQueueResponse
func (c *ClientWithResponses) RadarQueueWithResponse(ctx context.Context, host string, params *RadarQueueParams, reqEditors ...RequestEditorFn) (*RadarQueueResponse, error) {
	rsp, err := c.RadarQueue(ctx, host, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarQueueResponse(rsp)
}

// RadarServersWithResponse request returning *RadarServersResponse
func (c *ClientWithResponses) RadarServersWithResponse(ctx context.Context, params *RadarServersParams, reqEditors ...RequestEditorFn) (*RadarServersResponse, error) {
	rsp, err := c.RadarServers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarServersResponse(rsp)
}

// RadarServerWithResponse request returning *RadarServerResponse
func (c *ClientWithResponses) RadarServerWithResponse(ctx context.Context, id string, params *RadarServerParams, reqEditors ...RequestEditorFn) (*RadarServerResponse, error) {
	rsp, err := c.RadarServer(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarServerResponse(rsp)
}

// RadarStationsWithResponse request returning *RadarStationsResponse
func (c *ClientWithResponses) RadarStationsWithResponse(ctx context.Context, params *RadarStationsParams, reqEditors ...RequestEditorFn) (*RadarStationsResponse, error) {
	rsp, err := c.RadarStations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarStationsResponse(rsp)
}

// RadarStationWithResponse request returning *RadarStationResponse
func (c *ClientWithResponses) RadarStationWithResponse(ctx context.Context, stationId string, params *RadarStationParams, reqEditors ...RequestEditorFn) (*RadarStationResponse, error) {
	rsp, err := c.RadarStation(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarStationResponse(rsp)
}

// RadarStationAlarmsWithResponse request returning *RadarStationAlarmsResponse
func (c *ClientWithResponses) RadarStationAlarmsWithResponse(ctx context.Context, stationId string, reqEditors ...RequestEditorFn) (*RadarStationAlarmsResponse, error) {
	rsp, err := c.RadarStationAlarms(ctx, stationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRadarStationAlarmsResponse(rsp)
}

// ObsStationsWithResponse request returning *ObsStationsResponse
func (c *ClientWithResponses) ObsStationsWithResponse(ctx context.Context, params *ObsStationsParams, reqEditors ...RequestEditorFn) (*ObsStationsResponse, error) {
	rsp, err := c.ObsStations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObsStationsResponse(rsp)
}

// ObsStationWithResponse request returning *ObsStationResponse
func (c *ClientWithResponses) ObsStationWithResponse(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*ObsStationResponse, error) {
	rsp, err := c.ObsStation(ctx, stationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObsStationResponse(rsp)
}

// StationObservationListWithResponse request returning *StationObservationListResponse
func (c *ClientWithResponses) StationObservationListWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationListParams, reqEditors ...RequestEditorFn) (*StationObservationListResponse, error) {
	rsp, err := c.StationObservationList(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStationObservationListResponse(rsp)
}

// StationObservationLatestWithResponse request returning *StationObservationLatestResponse
func (c *ClientWithResponses) StationObservationLatestWithResponse(ctx context.Context, stationId ObservationStationId, params *StationObservationLatestParams, reqEditors ...RequestEditorFn) (*StationObservationLatestResponse, error) {
	rsp, err := c.StationObservationLatest(ctx, stationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStationObservationLatestResponse(rsp)
}

// StationObservationTimeWithResponse request returning *StationObservationTimeResponse
func (c *ClientWithResponses) StationObservationTimeWithResponse(ctx context.Context, stationId ObservationStationId, time time.Time, reqEditors ...RequestEditorFn) (*StationObservationTimeResponse, error) {
	rsp, err := c.StationObservationTime(ctx, stationId, time, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStationObservationTimeResponse(rsp)
}

// TafsWithResponse request returning *TafsResponse
func (c *ClientWithResponses) TafsWithResponse(ctx context.Context, stationId ObservationStationId, reqEditors ...RequestEditorFn) (*TafsResponse, error) {
	rsp, err := c.Tafs(ctx, stationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTafsResponse(rsp)
}

// TafWithResponse request returning *TafResponse
func (c *ClientWithResponses) TafWithResponse(ctx context.Context, stationId ObservationStationId, date Date, time Time, reqEditors ...RequestEditorFn) (*TafResponse, error) {
	rsp, err := c.Taf(ctx, stationId, date, time, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTafResponse(rsp)
}

// SatelliteThumbnailsWithResponse request returning *SatelliteThumbnailsResponse
func (c *ClientWithResponses) SatelliteThumbnailsWithResponse(ctx context.Context, area string, reqEditors ...RequestEditorFn) (*SatelliteThumbnailsResponse, error) {
	rsp, err := c.SatelliteThumbnails(ctx, area, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSatelliteThumbnailsResponse(rsp)
}

// ZoneListWithResponse request returning *ZoneListResponse
func (c *ClientWithResponses) ZoneListWithResponse(ctx context.Context, params *ZoneListParams, reqEditors ...RequestEditorFn) (*ZoneListResponse, error) {
	rsp, err := c.ZoneList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneListResponse(rsp)
}

// ZoneObsWithResponse request returning *ZoneObsResponse
func (c *ClientWithResponses) ZoneObsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneObsParams, reqEditors ...RequestEditorFn) (*ZoneObsResponse, error) {
	rsp, err := c.ZoneObs(ctx, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneObsResponse(rsp)
}

// ZoneStationsWithResponse request returning *ZoneStationsResponse
func (c *ClientWithResponses) ZoneStationsWithResponse(ctx context.Context, zoneId NWSZoneId, params *ZoneStationsParams, reqEditors ...RequestEditorFn) (*ZoneStationsResponse, error) {
	rsp, err := c.ZoneStations(ctx, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneStationsResponse(rsp)
}

// ZoneListTypeWithResponse request returning *ZoneListTypeResponse
func (c *ClientWithResponses) ZoneListTypeWithResponse(ctx context.Context, pType NWSZoneType, params *ZoneListTypeParams, reqEditors ...RequestEditorFn) (*ZoneListTypeResponse, error) {
	rsp, err := c.ZoneListType(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneListTypeResponse(rsp)
}

// ZoneWithResponse request returning *ZoneResponse
func (c *ClientWithResponses) ZoneWithResponse(ctx context.Context, pType NWSZoneType, zoneId NWSZoneId, params *ZoneParams, reqEditors ...RequestEditorFn) (*ZoneResponse, error) {
	rsp, err := c.Zone(ctx, pType, zoneId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneResponse(rsp)
}

// ZoneForecastWithResponse request returning *ZoneForecastResponse
func (c *ClientWithResponses) ZoneForecastWithResponse(ctx context.Context, pType string, zoneId NWSZoneId, reqEditors ...RequestEditorFn) (*ZoneForecastResponse, error) {
	rsp, err := c.ZoneForecast(ctx, pType, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZoneForecastResponse(rsp)
}

// ParseAlertsQueryResponse parses an HTTP response from a AlertsQueryWithResponse call
func ParseAlertsQueryResponse(rsp *http.Response) (*AlertsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsActiveResponse parses an HTTP response from a AlertsActiveWithResponse call
func ParseAlertsActiveResponse(rsp *http.Response) (*AlertsActiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsActiveAreaResponse parses an HTTP response from a AlertsActiveAreaWithResponse call
func ParseAlertsActiveAreaResponse(rsp *http.Response) (*AlertsActiveAreaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveAreaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsActiveCountResponse parses an HTTP response from a AlertsActiveCountWithResponse call
func ParseAlertsActiveCountResponse(rsp *http.Response) (*AlertsActiveCountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveCountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsActiveRegionResponse parses an HTTP response from a AlertsActiveRegionWithResponse call
func ParseAlertsActiveRegionResponse(rsp *http.Response) (*AlertsActiveRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsActiveZoneResponse parses an HTTP response from a AlertsActiveZoneWithResponse call
func ParseAlertsActiveZoneResponse(rsp *http.Response) (*AlertsActiveZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsActiveZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsTypesResponse parses an HTTP response from a AlertsTypesWithResponse call
func ParseAlertsTypesResponse(rsp *http.Response) (*AlertsTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAlertsSingleResponse parses an HTTP response from a AlertsSingleWithResponse call
func ParseAlertsSingleResponse(rsp *http.Response) (*AlertsSingleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AlertsSingleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCwsuResponse parses an HTTP response from a CwsuWithResponse call
func ParseCwsuResponse(rsp *http.Response) (*CwsuResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CwsuResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCwasResponse parses an HTTP response from a CwasWithResponse call
func ParseCwasResponse(rsp *http.Response) (*CwasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CwasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCwaResponse parses an HTTP response from a CwaWithResponse call
func ParseCwaResponse(rsp *http.Response) (*CwaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CwaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetQueryResponse parses an HTTP response from a SigmetQueryWithResponse call
func ParseSigmetQueryResponse(rsp *http.Response) (*SigmetQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetsByATSUResponse parses an HTTP response from a SigmetsByATSUWithResponse call
func ParseSigmetsByATSUResponse(rsp *http.Response) (*SigmetsByATSUResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetsByATSUResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetsByATSUByDateResponse parses an HTTP response from a SigmetsByATSUByDateWithResponse call
func ParseSigmetsByATSUByDateResponse(rsp *http.Response) (*SigmetsByATSUByDateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetsByATSUByDateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSigmetResponse parses an HTTP response from a SigmetWithResponse call
func ParseSigmetResponse(rsp *http.Response) (*SigmetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SigmetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGlossaryResponse parses an HTTP response from a GlossaryWithResponse call
func ParseGlossaryResponse(rsp *http.Response) (*GlossaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GlossaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGridpointResponse parses an HTTP response from a GridpointWithResponse call
func ParseGridpointResponse(rsp *http.Response) (*GridpointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGridpointForecastResponse parses an HTTP response from a GridpointForecastWithResponse call
func ParseGridpointForecastResponse(rsp *http.Response) (*GridpointForecastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointForecastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGridpointForecastHourlyResponse parses an HTTP response from a GridpointForecastHourlyWithResponse call
func ParseGridpointForecastHourlyResponse(rsp *http.Response) (*GridpointForecastHourlyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointForecastHourlyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGridpointStationsResponse parses an HTTP response from a GridpointStationsWithResponse call
func ParseGridpointStationsResponse(rsp *http.Response) (*GridpointStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GridpointStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIconsSummaryResponse parses an HTTP response from a IconsSummaryWithResponse call
func ParseIconsSummaryResponse(rsp *http.Response) (*IconsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IconsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIconsResponse parses an HTTP response from a IconsWithResponse call
func ParseIconsResponse(rsp *http.Response) (*IconsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IconsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseIconsDualConditionResponse parses an HTTP response from a IconsDualConditionWithResponse call
func ParseIconsDualConditionResponse(rsp *http.Response) (*IconsDualConditionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IconsDualConditionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOfficeResponse parses an HTTP response from a OfficeWithResponse call
func ParseOfficeResponse(rsp *http.Response) (*OfficeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOfficeHeadlinesResponse parses an HTTP response from a OfficeHeadlinesWithResponse call
func ParseOfficeHeadlinesResponse(rsp *http.Response) (*OfficeHeadlinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficeHeadlinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseOfficeHeadlineResponse parses an HTTP response from a OfficeHeadlineWithResponse call
func ParseOfficeHeadlineResponse(rsp *http.Response) (*OfficeHeadlineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OfficeHeadlineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePointResponse parses an HTTP response from a PointWithResponse call
func ParsePointResponse(rsp *http.Response) (*PointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePointStationsResponse parses an HTTP response from a PointStationsWithResponse call
func ParsePointStationsResponse(rsp *http.Response) (*PointStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PointStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductsQueryResponse parses an HTTP response from a ProductsQueryWithResponse call
func ParseProductsQueryResponse(rsp *http.Response) (*ProductsQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductLocationsResponse parses an HTTP response from a ProductLocationsWithResponse call
func ParseProductLocationsResponse(rsp *http.Response) (*ProductLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLocationProductsResponse parses an HTTP response from a LocationProductsWithResponse call
func ParseLocationProductsResponse(rsp *http.Response) (*LocationProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LocationProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductTypesResponse parses an HTTP response from a ProductTypesWithResponse call
func ParseProductTypesResponse(rsp *http.Response) (*ProductTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductsTypeResponse parses an HTTP response from a ProductsTypeWithResponse call
func ParseProductsTypeResponse(rsp *http.Response) (*ProductsTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductsTypeLocationsResponse parses an HTTP response from a ProductsTypeLocationsWithResponse call
func ParseProductsTypeLocationsResponse(rsp *http.Response) (*ProductsTypeLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsTypeLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductsTypeLocationResponse parses an HTTP response from a ProductsTypeLocationWithResponse call
func ParseProductsTypeLocationResponse(rsp *http.Response) (*ProductsTypeLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductsTypeLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseProductResponse parses an HTTP response from a ProductWithResponse call
func ParseProductResponse(rsp *http.Response) (*ProductResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarProfilerResponse parses an HTTP response from a RadarProfilerWithResponse call
func ParseRadarProfilerResponse(rsp *http.Response) (*RadarProfilerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarProfilerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarQueueResponse parses an HTTP response from a RadarQueueWithResponse call
func ParseRadarQueueResponse(rsp *http.Response) (*RadarQueueResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarServersResponse parses an HTTP response from a RadarServersWithResponse call
func ParseRadarServersResponse(rsp *http.Response) (*RadarServersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarServersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarServerResponse parses an HTTP response from a RadarServerWithResponse call
func ParseRadarServerResponse(rsp *http.Response) (*RadarServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarStationsResponse parses an HTTP response from a RadarStationsWithResponse call
func ParseRadarStationsResponse(rsp *http.Response) (*RadarStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarStationResponse parses an HTTP response from a RadarStationWithResponse call
func ParseRadarStationResponse(rsp *http.Response) (*RadarStationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarStationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRadarStationAlarmsResponse parses an HTTP response from a RadarStationAlarmsWithResponse call
func ParseRadarStationAlarmsResponse(rsp *http.Response) (*RadarStationAlarmsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RadarStationAlarmsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObsStationsResponse parses an HTTP response from a ObsStationsWithResponse call
func ParseObsStationsResponse(rsp *http.Response) (*ObsStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObsStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObsStationResponse parses an HTTP response from a ObsStationWithResponse call
func ParseObsStationResponse(rsp *http.Response) (*ObsStationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObsStationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStationObservationListResponse parses an HTTP response from a StationObservationListWithResponse call
func ParseStationObservationListResponse(rsp *http.Response) (*StationObservationListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StationObservationListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStationObservationLatestResponse parses an HTTP response from a StationObservationLatestWithResponse call
func ParseStationObservationLatestResponse(rsp *http.Response) (*StationObservationLatestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StationObservationLatestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStationObservationTimeResponse parses an HTTP response from a StationObservationTimeWithResponse call
func ParseStationObservationTimeResponse(rsp *http.Response) (*StationObservationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StationObservationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTafsResponse parses an HTTP response from a TafsWithResponse call
func ParseTafsResponse(rsp *http.Response) (*TafsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TafsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTafResponse parses an HTTP response from a TafWithResponse call
func ParseTafResponse(rsp *http.Response) (*TafResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TafResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSatelliteThumbnailsResponse parses an HTTP response from a SatelliteThumbnailsWithResponse call
func ParseSatelliteThumbnailsResponse(rsp *http.Response) (*SatelliteThumbnailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SatelliteThumbnailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseZoneListResponse parses an HTTP response from a ZoneListWithResponse call
func ParseZoneListResponse(rsp *http.Response) (*ZoneListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseZoneObsResponse parses an HTTP response from a ZoneObsWithResponse call
func ParseZoneObsResponse(rsp *http.Response) (*ZoneObsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneObsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseZoneStationsResponse parses an HTTP response from a ZoneStationsWithResponse call
func ParseZoneStationsResponse(rsp *http.Response) (*ZoneStationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneStationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseZoneListTypeResponse parses an HTTP response from a ZoneListTypeWithResponse call
func ParseZoneListTypeResponse(rsp *http.Response) (*ZoneListTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneListTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseZoneResponse parses an HTTP response from a ZoneWithResponse call
func ParseZoneResponse(rsp *http.Response) (*ZoneResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseZoneForecastResponse parses an HTTP response from a ZoneForecastWithResponse call
func ParseZoneForecastResponse(rsp *http.Response) (*ZoneForecastResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZoneForecastResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ProblemDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /alerts)
	AlertsQuery(ctx echo.Context, params AlertsQueryParams) error

	// (GET /alerts/active)
	AlertsActive(ctx echo.Context, params AlertsActiveParams) error

	// (GET /alerts/active/area/{area})
	AlertsActiveArea(ctx echo.Context, area AreaCode) error

	// (GET /alerts/active/count)
	AlertsActiveCount(ctx echo.Context) error

	// (GET /alerts/active/region/{region})
	AlertsActiveRegion(ctx echo.Context, region MarineRegionCode) error

	// (GET /alerts/active/zone/{zoneId})
	AlertsActiveZone(ctx echo.Context, zoneId NWSZoneId) error

	// (GET /alerts/types)
	AlertsTypes(ctx echo.Context) error

	// (GET /alerts/{id})
	AlertsSingle(ctx echo.Context, id AlertId) error

	// (GET /aviation/cwsus/{cwsuId})
	Cwsu(ctx echo.Context, cwsuId NWSCenterWeatherServiceUnitId) error

	// (GET /aviation/cwsus/{cwsuId}/cwas)
	Cwas(ctx echo.Context, cwsuId NWSCenterWeatherServiceUnitId) error

	// (GET /aviation/cwsus/{cwsuId}/cwas/{date}/{sequence})
	Cwa(ctx echo.Context, cwsuId NWSCenterWeatherServiceUnitId, date Date, sequence int) error

	// (GET /aviation/sigmets)
	SigmetQuery(ctx echo.Context, params SigmetQueryParams) error

	// (GET /aviation/sigmets/{atsu})
	SigmetsByATSU(ctx echo.Context, atsu ATSUIdentifier) error

	// (GET /aviation/sigmets/{atsu}/{date})
	SigmetsByATSUByDate(ctx echo.Context, atsu ATSUIdentifier, date Date) error

	// (GET /aviation/sigmets/{atsu}/{date}/{time})
	Sigmet(ctx echo.Context, atsu ATSUIdentifier, date Date, time Time) error

	// (GET /glossary)
	Glossary(ctx echo.Context) error

	// (GET /gridpoints/{wfo}/{x},{y})
	Gridpoint(ctx echo.Context, wfo GridpointWFO, x GridpointX, y GridpointY) error

	// (GET /gridpoints/{wfo}/{x},{y}/forecast)
	GridpointForecast(ctx echo.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params GridpointForecastParams) error

	// (GET /gridpoints/{wfo}/{x},{y}/forecast/hourly)
	GridpointForecastHourly(ctx echo.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params GridpointForecastHourlyParams) error

	// (GET /gridpoints/{wfo}/{x},{y}/stations)
	GridpointStations(ctx echo.Context, wfo GridpointWFO, x GridpointX, y GridpointY, params GridpointStationsParams) error

	// (GET /icons)
	IconsSummary(ctx echo.Context) error

	// (GET /icons/{set}/{timeOfDay}/{first})
	Icons(ctx echo.Context, set string, timeOfDay string, first string, params IconsParams) error

	// (GET /icons/{set}/{timeOfDay}/{first}/{second})
	IconsDualCondition(ctx echo.Context, set string, timeOfDay string, first string, second string, params IconsDualConditionParams) error

	// (GET /offices/{officeId})
	Office(ctx echo.Context, nWSOfficeIdReference NWSOfficeIdReference) error

	// (GET /offices/{officeId}/headlines)
	OfficeHeadlines(ctx echo.Context, nWSOfficeIdReference NWSOfficeIdReference) error

	// (GET /offices/{officeId}/headlines/{headlineId})
	OfficeHeadline(ctx echo.Context, nWSOfficeIdReference NWSOfficeIdReference, headlineId string) error

	// (GET /points/{point})
	Point(ctx echo.Context, point PathPoint) error

	// (GET /points/{point}/stations)
	PointStations(ctx echo.Context, point PathPoint) error

	// (GET /products)
	ProductsQuery(ctx echo.Context, params ProductsQueryParams) error

	// (GET /products/locations)
	ProductLocations(ctx echo.Context) error

	// (GET /products/locations/{locationId}/types)
	LocationProducts(ctx echo.Context, locationId string) error

	// (GET /products/types)
	ProductTypes(ctx echo.Context) error

	// (GET /products/types/{typeId})
	ProductsType(ctx echo.Context, typeId string) error

	// (GET /products/types/{typeId}/locations)
	ProductsTypeLocations(ctx echo.Context, typeId string) error

	// (GET /products/types/{typeId}/locations/{locationId})
	ProductsTypeLocation(ctx echo.Context, typeId string, locationId string) error

	// (GET /products/{productId})
	Product(ctx echo.Context, productId string) error

	// (GET /radar/profilers/{stationId})
	RadarProfiler(ctx echo.Context, stationId string, params RadarProfilerParams) error

	// (GET /radar/queues/{host})
	RadarQueue(ctx echo.Context, host string, params RadarQueueParams) error

	// (GET /radar/servers)
	RadarServers(ctx echo.Context, params RadarServersParams) error

	// (GET /radar/servers/{id})
	RadarServer(ctx echo.Context, id string, params RadarServerParams) error

	// (GET /radar/stations)
	RadarStations(ctx echo.Context, params RadarStationsParams) error

	// (GET /radar/stations/{stationId})
	RadarStation(ctx echo.Context, stationId string, params RadarStationParams) error

	// (GET /radar/stations/{stationId}/alarms)
	RadarStationAlarms(ctx echo.Context, stationId string) error

	// (GET /stations)
	ObsStations(ctx echo.Context, params ObsStationsParams) error

	// (GET /stations/{stationId})
	ObsStation(ctx echo.Context, stationId ObservationStationId) error

	// (GET /stations/{stationId}/observations)
	StationObservationList(ctx echo.Context, stationId ObservationStationId, params StationObservationListParams) error

	// (GET /stations/{stationId}/observations/latest)
	StationObservationLatest(ctx echo.Context, stationId ObservationStationId, params StationObservationLatestParams) error

	// (GET /stations/{stationId}/observations/{time})
	StationObservationTime(ctx echo.Context, stationId ObservationStationId, time time.Time) error

	// (GET /stations/{stationId}/tafs)
	Tafs(ctx echo.Context, stationId ObservationStationId) error

	// (GET /stations/{stationId}/tafs/{date}/{time})
	Taf(ctx echo.Context, stationId ObservationStationId, date Date, time Time) error

	// (GET /thumbnails/satellite/{area})
	SatelliteThumbnails(ctx echo.Context, area string) error

	// (GET /zones)
	ZoneList(ctx echo.Context, params ZoneListParams) error

	// (GET /zones/forecast/{zoneId}/observations)
	ZoneObs(ctx echo.Context, zoneId NWSZoneId, params ZoneObsParams) error

	// (GET /zones/forecast/{zoneId}/stations)
	ZoneStations(ctx echo.Context, zoneId NWSZoneId, params ZoneStationsParams) error

	// (GET /zones/{type})
	ZoneListType(ctx echo.Context, pType NWSZoneType, params ZoneListTypeParams) error

	// (GET /zones/{type}/{zoneId})
	Zone(ctx echo.Context, pType NWSZoneType, zoneId NWSZoneId, params ZoneParams) error

	// (GET /zones/{type}/{zoneId}/forecast)
	ZoneForecast(ctx echo.Context, pType string, zoneId NWSZoneId) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AlertsQuery converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsQuery(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AlertsQueryParams
	// ------------- Optional query parameter "active" -------------

	err = runtime.BindQueryParameter("form", true, false, "active", ctx.QueryParams(), &params.Active)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter active: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "message_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "message_type", ctx.QueryParams(), &params.MessageType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter message_type: %s", err))
	}

	// ------------- Optional query parameter "event" -------------

	err = runtime.BindQueryParameter("form", false, false, "event", ctx.QueryParams(), &params.Event)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", false, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "area" -------------

	err = runtime.BindQueryParameter("form", false, false, "area", ctx.QueryParams(), &params.Area)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter area: %s", err))
	}

	// ------------- Optional query parameter "point" -------------

	err = runtime.BindQueryParameter("form", true, false, "point", ctx.QueryParams(), &params.Point)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter point: %s", err))
	}

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", false, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "region_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "region_type", ctx.QueryParams(), &params.RegionType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_type: %s", err))
	}

	// ------------- Optional query parameter "zone" -------------

	err = runtime.BindQueryParameter("form", false, false, "zone", ctx.QueryParams(), &params.Zone)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zone: %s", err))
	}

	// ------------- Optional query parameter "urgency" -------------

	err = runtime.BindQueryParameter("form", false, false, "urgency", ctx.QueryParams(), &params.Urgency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urgency: %s", err))
	}

	// ------------- Optional query parameter "severity" -------------

	err = runtime.BindQueryParameter("form", false, false, "severity", ctx.QueryParams(), &params.Severity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity: %s", err))
	}

	// ------------- Optional query parameter "certainty" -------------

	err = runtime.BindQueryParameter("form", false, false, "certainty", ctx.QueryParams(), &params.Certainty)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter certainty: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsQuery(ctx, params)
	return err
}

// AlertsActive converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsActive(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AlertsActiveParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", false, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "message_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "message_type", ctx.QueryParams(), &params.MessageType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter message_type: %s", err))
	}

	// ------------- Optional query parameter "event" -------------

	err = runtime.BindQueryParameter("form", false, false, "event", ctx.QueryParams(), &params.Event)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter event: %s", err))
	}

	// ------------- Optional query parameter "code" -------------

	err = runtime.BindQueryParameter("form", false, false, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// ------------- Optional query parameter "area" -------------

	err = runtime.BindQueryParameter("form", false, false, "area", ctx.QueryParams(), &params.Area)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter area: %s", err))
	}

	// ------------- Optional query parameter "point" -------------

	err = runtime.BindQueryParameter("form", true, false, "point", ctx.QueryParams(), &params.Point)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter point: %s", err))
	}

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", false, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "region_type" -------------

	err = runtime.BindQueryParameter("form", true, false, "region_type", ctx.QueryParams(), &params.RegionType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region_type: %s", err))
	}

	// ------------- Optional query parameter "zone" -------------

	err = runtime.BindQueryParameter("form", false, false, "zone", ctx.QueryParams(), &params.Zone)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zone: %s", err))
	}

	// ------------- Optional query parameter "urgency" -------------

	err = runtime.BindQueryParameter("form", false, false, "urgency", ctx.QueryParams(), &params.Urgency)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter urgency: %s", err))
	}

	// ------------- Optional query parameter "severity" -------------

	err = runtime.BindQueryParameter("form", false, false, "severity", ctx.QueryParams(), &params.Severity)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter severity: %s", err))
	}

	// ------------- Optional query parameter "certainty" -------------

	err = runtime.BindQueryParameter("form", false, false, "certainty", ctx.QueryParams(), &params.Certainty)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter certainty: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsActive(ctx, params)
	return err
}

// AlertsActiveArea converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsActiveArea(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "area" -------------
	var area AreaCode

	err = runtime.BindStyledParameterWithLocation("simple", false, "area", runtime.ParamLocationPath, ctx.Param("area"), &area)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter area: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsActiveArea(ctx, area)
	return err
}

// AlertsActiveCount converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsActiveCount(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsActiveCount(ctx)
	return err
}

// AlertsActiveRegion converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsActiveRegion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "region" -------------
	var region MarineRegionCode

	err = runtime.BindStyledParameterWithLocation("simple", false, "region", runtime.ParamLocationPath, ctx.Param("region"), &region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsActiveRegion(ctx, region)
	return err
}

// AlertsActiveZone converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsActiveZone(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "zoneId" -------------
	var zoneId NWSZoneId

	err = runtime.BindStyledParameterWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, ctx.Param("zoneId"), &zoneId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zoneId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsActiveZone(ctx, zoneId)
	return err
}

// AlertsTypes converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsTypes(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsTypes(ctx)
	return err
}

// AlertsSingle converts echo context to params.
func (w *ServerInterfaceWrapper) AlertsSingle(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id AlertId

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AlertsSingle(ctx, id)
	return err
}

// Cwsu converts echo context to params.
func (w *ServerInterfaceWrapper) Cwsu(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "cwsuId" -------------
	var cwsuId NWSCenterWeatherServiceUnitId

	err = runtime.BindStyledParameterWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, ctx.Param("cwsuId"), &cwsuId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cwsuId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Cwsu(ctx, cwsuId)
	return err
}

// Cwas converts echo context to params.
func (w *ServerInterfaceWrapper) Cwas(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "cwsuId" -------------
	var cwsuId NWSCenterWeatherServiceUnitId

	err = runtime.BindStyledParameterWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, ctx.Param("cwsuId"), &cwsuId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cwsuId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Cwas(ctx, cwsuId)
	return err
}

// Cwa converts echo context to params.
func (w *ServerInterfaceWrapper) Cwa(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "cwsuId" -------------
	var cwsuId NWSCenterWeatherServiceUnitId

	err = runtime.BindStyledParameterWithLocation("simple", false, "cwsuId", runtime.ParamLocationPath, ctx.Param("cwsuId"), &cwsuId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cwsuId: %s", err))
	}

	// ------------- Path parameter "date" -------------
	var date Date

	err = runtime.BindStyledParameterWithLocation("simple", false, "date", runtime.ParamLocationPath, ctx.Param("date"), &date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Path parameter "sequence" -------------
	var sequence int

	err = runtime.BindStyledParameterWithLocation("simple", false, "sequence", runtime.ParamLocationPath, ctx.Param("sequence"), &sequence)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sequence: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Cwa(ctx, cwsuId, date, sequence)
	return err
}

// SigmetQuery converts echo context to params.
func (w *ServerInterfaceWrapper) SigmetQuery(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SigmetQueryParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "date" -------------

	err = runtime.BindQueryParameter("form", true, false, "date", ctx.QueryParams(), &params.Date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Optional query parameter "atsu" -------------

	err = runtime.BindQueryParameter("form", true, false, "atsu", ctx.QueryParams(), &params.Atsu)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter atsu: %s", err))
	}

	// ------------- Optional query parameter "sequence" -------------

	err = runtime.BindQueryParameter("form", true, false, "sequence", ctx.QueryParams(), &params.Sequence)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sequence: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SigmetQuery(ctx, params)
	return err
}

// SigmetsByATSU converts echo context to params.
func (w *ServerInterfaceWrapper) SigmetsByATSU(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "atsu" -------------
	var atsu ATSUIdentifier

	err = runtime.BindStyledParameterWithLocation("simple", false, "atsu", runtime.ParamLocationPath, ctx.Param("atsu"), &atsu)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter atsu: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SigmetsByATSU(ctx, atsu)
	return err
}

// SigmetsByATSUByDate converts echo context to params.
func (w *ServerInterfaceWrapper) SigmetsByATSUByDate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "atsu" -------------
	var atsu ATSUIdentifier

	err = runtime.BindStyledParameterWithLocation("simple", false, "atsu", runtime.ParamLocationPath, ctx.Param("atsu"), &atsu)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter atsu: %s", err))
	}

	// ------------- Path parameter "date" -------------
	var date Date

	err = runtime.BindStyledParameterWithLocation("simple", false, "date", runtime.ParamLocationPath, ctx.Param("date"), &date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SigmetsByATSUByDate(ctx, atsu, date)
	return err
}

// Sigmet converts echo context to params.
func (w *ServerInterfaceWrapper) Sigmet(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "atsu" -------------
	var atsu ATSUIdentifier

	err = runtime.BindStyledParameterWithLocation("simple", false, "atsu", runtime.ParamLocationPath, ctx.Param("atsu"), &atsu)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter atsu: %s", err))
	}

	// ------------- Path parameter "date" -------------
	var date Date

	err = runtime.BindStyledParameterWithLocation("simple", false, "date", runtime.ParamLocationPath, ctx.Param("date"), &date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Path parameter "time" -------------
	var time Time

	err = runtime.BindStyledParameterWithLocation("simple", false, "time", runtime.ParamLocationPath, ctx.Param("time"), &time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Sigmet(ctx, atsu, date, time)
	return err
}

// Glossary converts echo context to params.
func (w *ServerInterfaceWrapper) Glossary(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Glossary(ctx)
	return err
}

// Gridpoint converts echo context to params.
func (w *ServerInterfaceWrapper) Gridpoint(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "wfo" -------------
	var wfo GridpointWFO

	err = runtime.BindStyledParameterWithLocation("simple", false, "wfo", runtime.ParamLocationPath, ctx.Param("wfo"), &wfo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wfo: %s", err))
	}

	// ------------- Path parameter "x" -------------
	var x GridpointX

	err = runtime.BindStyledParameterWithLocation("simple", false, "x", runtime.ParamLocationPath, ctx.Param("x"), &x)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x: %s", err))
	}

	// ------------- Path parameter "y" -------------
	var y GridpointY

	err = runtime.BindStyledParameterWithLocation("simple", false, "y", runtime.ParamLocationPath, ctx.Param("y"), &y)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter y: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Gridpoint(ctx, wfo, x, y)
	return err
}

// GridpointForecast converts echo context to params.
func (w *ServerInterfaceWrapper) GridpointForecast(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "wfo" -------------
	var wfo GridpointWFO

	err = runtime.BindStyledParameterWithLocation("simple", false, "wfo", runtime.ParamLocationPath, ctx.Param("wfo"), &wfo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wfo: %s", err))
	}

	// ------------- Path parameter "x" -------------
	var x GridpointX

	err = runtime.BindStyledParameterWithLocation("simple", false, "x", runtime.ParamLocationPath, ctx.Param("x"), &x)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x: %s", err))
	}

	// ------------- Path parameter "y" -------------
	var y GridpointY

	err = runtime.BindStyledParameterWithLocation("simple", false, "y", runtime.ParamLocationPath, ctx.Param("y"), &y)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter y: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GridpointForecastParams
	// ------------- Optional query parameter "units" -------------

	err = runtime.BindQueryParameter("form", true, false, "units", ctx.QueryParams(), &params.Units)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter units: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Feature-Flags" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Feature-Flags")]; found {
		var FeatureFlags GridpointForecastFeatureFlags
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Feature-Flags, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, valueList[0], &FeatureFlags)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Feature-Flags: %s", err))
		}

		params.FeatureFlags = &FeatureFlags
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GridpointForecast(ctx, wfo, x, y, params)
	return err
}

// GridpointForecastHourly converts echo context to params.
func (w *ServerInterfaceWrapper) GridpointForecastHourly(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "wfo" -------------
	var wfo GridpointWFO

	err = runtime.BindStyledParameterWithLocation("simple", false, "wfo", runtime.ParamLocationPath, ctx.Param("wfo"), &wfo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wfo: %s", err))
	}

	// ------------- Path parameter "x" -------------
	var x GridpointX

	err = runtime.BindStyledParameterWithLocation("simple", false, "x", runtime.ParamLocationPath, ctx.Param("x"), &x)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x: %s", err))
	}

	// ------------- Path parameter "y" -------------
	var y GridpointY

	err = runtime.BindStyledParameterWithLocation("simple", false, "y", runtime.ParamLocationPath, ctx.Param("y"), &y)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter y: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GridpointForecastHourlyParams
	// ------------- Optional query parameter "units" -------------

	err = runtime.BindQueryParameter("form", true, false, "units", ctx.QueryParams(), &params.Units)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter units: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Optional header parameter "Feature-Flags" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Feature-Flags")]; found {
		var FeatureFlags GridpointForecastFeatureFlags
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Feature-Flags, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Feature-Flags", runtime.ParamLocationHeader, valueList[0], &FeatureFlags)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Feature-Flags: %s", err))
		}

		params.FeatureFlags = &FeatureFlags
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GridpointForecastHourly(ctx, wfo, x, y, params)
	return err
}

// GridpointStations converts echo context to params.
func (w *ServerInterfaceWrapper) GridpointStations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "wfo" -------------
	var wfo GridpointWFO

	err = runtime.BindStyledParameterWithLocation("simple", false, "wfo", runtime.ParamLocationPath, ctx.Param("wfo"), &wfo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wfo: %s", err))
	}

	// ------------- Path parameter "x" -------------
	var x GridpointX

	err = runtime.BindStyledParameterWithLocation("simple", false, "x", runtime.ParamLocationPath, ctx.Param("x"), &x)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x: %s", err))
	}

	// ------------- Path parameter "y" -------------
	var y GridpointY

	err = runtime.BindStyledParameterWithLocation("simple", false, "y", runtime.ParamLocationPath, ctx.Param("y"), &y)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter y: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GridpointStationsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GridpointStations(ctx, wfo, x, y, params)
	return err
}

// IconsSummary converts echo context to params.
func (w *ServerInterfaceWrapper) IconsSummary(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IconsSummary(ctx)
	return err
}

// Icons converts echo context to params.
func (w *ServerInterfaceWrapper) Icons(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "set" -------------
	var set string

	err = runtime.BindStyledParameterWithLocation("simple", false, "set", runtime.ParamLocationPath, ctx.Param("set"), &set)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter set: %s", err))
	}

	// ------------- Path parameter "timeOfDay" -------------
	var timeOfDay string

	err = runtime.BindStyledParameterWithLocation("simple", false, "timeOfDay", runtime.ParamLocationPath, ctx.Param("timeOfDay"), &timeOfDay)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeOfDay: %s", err))
	}

	// ------------- Path parameter "first" -------------
	var first string

	err = runtime.BindStyledParameterWithLocation("simple", false, "first", runtime.ParamLocationPath, ctx.Param("first"), &first)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params IconsParams
	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "fontsize" -------------

	err = runtime.BindQueryParameter("form", true, false, "fontsize", ctx.QueryParams(), &params.Fontsize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fontsize: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Icons(ctx, set, timeOfDay, first, params)
	return err
}

// IconsDualCondition converts echo context to params.
func (w *ServerInterfaceWrapper) IconsDualCondition(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "set" -------------
	var set string

	err = runtime.BindStyledParameterWithLocation("simple", false, "set", runtime.ParamLocationPath, ctx.Param("set"), &set)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter set: %s", err))
	}

	// ------------- Path parameter "timeOfDay" -------------
	var timeOfDay string

	err = runtime.BindStyledParameterWithLocation("simple", false, "timeOfDay", runtime.ParamLocationPath, ctx.Param("timeOfDay"), &timeOfDay)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timeOfDay: %s", err))
	}

	// ------------- Path parameter "first" -------------
	var first string

	err = runtime.BindStyledParameterWithLocation("simple", false, "first", runtime.ParamLocationPath, ctx.Param("first"), &first)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Path parameter "second" -------------
	var second string

	err = runtime.BindStyledParameterWithLocation("simple", false, "second", runtime.ParamLocationPath, ctx.Param("second"), &second)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter second: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params IconsDualConditionParams
	// ------------- Optional query parameter "size" -------------

	err = runtime.BindQueryParameter("form", true, false, "size", ctx.QueryParams(), &params.Size)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter size: %s", err))
	}

	// ------------- Optional query parameter "fontsize" -------------

	err = runtime.BindQueryParameter("form", true, false, "fontsize", ctx.QueryParams(), &params.Fontsize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fontsize: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.IconsDualCondition(ctx, set, timeOfDay, first, second, params)
	return err
}

// Office converts echo context to params.
func (w *ServerInterfaceWrapper) Office(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "officeId" -------------
	var nWSOfficeIdReference NWSOfficeIdReference

	err = runtime.BindStyledParameterWithLocation("simple", false, "officeId", runtime.ParamLocationPath, ctx.Param("officeId"), &nWSOfficeIdReference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter officeId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Office(ctx, nWSOfficeIdReference)
	return err
}

// OfficeHeadlines converts echo context to params.
func (w *ServerInterfaceWrapper) OfficeHeadlines(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "officeId" -------------
	var nWSOfficeIdReference NWSOfficeIdReference

	err = runtime.BindStyledParameterWithLocation("simple", false, "officeId", runtime.ParamLocationPath, ctx.Param("officeId"), &nWSOfficeIdReference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter officeId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OfficeHeadlines(ctx, nWSOfficeIdReference)
	return err
}

// OfficeHeadline converts echo context to params.
func (w *ServerInterfaceWrapper) OfficeHeadline(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "officeId" -------------
	var nWSOfficeIdReference NWSOfficeIdReference

	err = runtime.BindStyledParameterWithLocation("simple", false, "officeId", runtime.ParamLocationPath, ctx.Param("officeId"), &nWSOfficeIdReference)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter officeId: %s", err))
	}

	// ------------- Path parameter "headlineId" -------------
	var headlineId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "headlineId", runtime.ParamLocationPath, ctx.Param("headlineId"), &headlineId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter headlineId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.OfficeHeadline(ctx, nWSOfficeIdReference, headlineId)
	return err
}

// Point converts echo context to params.
func (w *ServerInterfaceWrapper) Point(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "point" -------------
	var point PathPoint

	err = runtime.BindStyledParameterWithLocation("simple", false, "point", runtime.ParamLocationPath, ctx.Param("point"), &point)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter point: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Point(ctx, point)
	return err
}

// PointStations converts echo context to params.
func (w *ServerInterfaceWrapper) PointStations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "point" -------------
	var point PathPoint

	err = runtime.BindStyledParameterWithLocation("simple", false, "point", runtime.ParamLocationPath, ctx.Param("point"), &point)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter point: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PointStations(ctx, point)
	return err
}

// ProductsQuery converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsQuery(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProductsQueryParams
	// ------------- Optional query parameter "location" -------------

	err = runtime.BindQueryParameter("form", false, false, "location", ctx.QueryParams(), &params.Location)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter location: %s", err))
	}

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "office" -------------

	err = runtime.BindQueryParameter("form", false, false, "office", ctx.QueryParams(), &params.Office)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter office: %s", err))
	}

	// ------------- Optional query parameter "wmoid" -------------

	err = runtime.BindQueryParameter("form", false, false, "wmoid", ctx.QueryParams(), &params.Wmoid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter wmoid: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", false, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsQuery(ctx, params)
	return err
}

// ProductLocations converts echo context to params.
func (w *ServerInterfaceWrapper) ProductLocations(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductLocations(ctx)
	return err
}

// LocationProducts converts echo context to params.
func (w *ServerInterfaceWrapper) LocationProducts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "locationId" -------------
	var locationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationId", runtime.ParamLocationPath, ctx.Param("locationId"), &locationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter locationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LocationProducts(ctx, locationId)
	return err
}

// ProductTypes converts echo context to params.
func (w *ServerInterfaceWrapper) ProductTypes(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductTypes(ctx)
	return err
}

// ProductsType converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "typeId" -------------
	var typeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "typeId", runtime.ParamLocationPath, ctx.Param("typeId"), &typeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter typeId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsType(ctx, typeId)
	return err
}

// ProductsTypeLocations converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsTypeLocations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "typeId" -------------
	var typeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "typeId", runtime.ParamLocationPath, ctx.Param("typeId"), &typeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter typeId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsTypeLocations(ctx, typeId)
	return err
}

// ProductsTypeLocation converts echo context to params.
func (w *ServerInterfaceWrapper) ProductsTypeLocation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "typeId" -------------
	var typeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "typeId", runtime.ParamLocationPath, ctx.Param("typeId"), &typeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter typeId: %s", err))
	}

	// ------------- Path parameter "locationId" -------------
	var locationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "locationId", runtime.ParamLocationPath, ctx.Param("locationId"), &locationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter locationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ProductsTypeLocation(ctx, typeId, locationId)
	return err
}

// Product converts echo context to params.
func (w *ServerInterfaceWrapper) Product(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "productId" -------------
	var productId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "productId", runtime.ParamLocationPath, ctx.Param("productId"), &productId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter productId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Product(ctx, productId)
	return err
}

// RadarProfiler converts echo context to params.
func (w *ServerInterfaceWrapper) RadarProfiler(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RadarProfilerParams
	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", ctx.QueryParams(), &params.Time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	// ------------- Optional query parameter "interval" -------------

	err = runtime.BindQueryParameter("form", true, false, "interval", ctx.QueryParams(), &params.Interval)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter interval: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarProfiler(ctx, stationId, params)
	return err
}

// RadarQueue converts echo context to params.
func (w *ServerInterfaceWrapper) RadarQueue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "host" -------------
	var host string

	err = runtime.BindStyledParameterWithLocation("simple", false, "host", runtime.ParamLocationPath, ctx.Param("host"), &host)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RadarQueueParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "arrived" -------------

	err = runtime.BindQueryParameter("form", true, false, "arrived", ctx.QueryParams(), &params.Arrived)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter arrived: %s", err))
	}

	// ------------- Optional query parameter "created" -------------

	err = runtime.BindQueryParameter("form", true, false, "created", ctx.QueryParams(), &params.Created)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter created: %s", err))
	}

	// ------------- Optional query parameter "published" -------------

	err = runtime.BindQueryParameter("form", true, false, "published", ctx.QueryParams(), &params.Published)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter published: %s", err))
	}

	// ------------- Optional query parameter "station" -------------

	err = runtime.BindQueryParameter("form", true, false, "station", ctx.QueryParams(), &params.Station)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter station: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "feed" -------------

	err = runtime.BindQueryParameter("form", true, false, "feed", ctx.QueryParams(), &params.Feed)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feed: %s", err))
	}

	// ------------- Optional query parameter "resolution" -------------

	err = runtime.BindQueryParameter("form", true, false, "resolution", ctx.QueryParams(), &params.Resolution)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resolution: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarQueue(ctx, host, params)
	return err
}

// RadarServers converts echo context to params.
func (w *ServerInterfaceWrapper) RadarServers(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RadarServersParams
	// ------------- Optional query parameter "reportingHost" -------------

	err = runtime.BindQueryParameter("form", true, false, "reportingHost", ctx.QueryParams(), &params.ReportingHost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reportingHost: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarServers(ctx, params)
	return err
}

// RadarServer converts echo context to params.
func (w *ServerInterfaceWrapper) RadarServer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RadarServerParams
	// ------------- Optional query parameter "reportingHost" -------------

	err = runtime.BindQueryParameter("form", true, false, "reportingHost", ctx.QueryParams(), &params.ReportingHost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reportingHost: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarServer(ctx, id, params)
	return err
}

// RadarStations converts echo context to params.
func (w *ServerInterfaceWrapper) RadarStations(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RadarStationsParams
	// ------------- Optional query parameter "stationType" -------------

	err = runtime.BindQueryParameter("form", false, false, "stationType", ctx.QueryParams(), &params.StationType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationType: %s", err))
	}

	// ------------- Optional query parameter "reportingHost" -------------

	err = runtime.BindQueryParameter("form", true, false, "reportingHost", ctx.QueryParams(), &params.ReportingHost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reportingHost: %s", err))
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", ctx.QueryParams(), &params.Host)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarStations(ctx, params)
	return err
}

// RadarStation converts echo context to params.
func (w *ServerInterfaceWrapper) RadarStation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RadarStationParams
	// ------------- Optional query parameter "reportingHost" -------------

	err = runtime.BindQueryParameter("form", true, false, "reportingHost", ctx.QueryParams(), &params.ReportingHost)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reportingHost: %s", err))
	}

	// ------------- Optional query parameter "host" -------------

	err = runtime.BindQueryParameter("form", true, false, "host", ctx.QueryParams(), &params.Host)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter host: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarStation(ctx, stationId, params)
	return err
}

// RadarStationAlarms converts echo context to params.
func (w *ServerInterfaceWrapper) RadarStationAlarms(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RadarStationAlarms(ctx, stationId)
	return err
}

// ObsStations converts echo context to params.
func (w *ServerInterfaceWrapper) ObsStations(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ObsStationsParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ObsStations(ctx, params)
	return err
}

// ObsStation converts echo context to params.
func (w *ServerInterfaceWrapper) ObsStation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId ObservationStationId

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ObsStation(ctx, stationId)
	return err
}

// StationObservationList converts echo context to params.
func (w *ServerInterfaceWrapper) StationObservationList(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId ObservationStationId

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StationObservationListParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StationObservationList(ctx, stationId, params)
	return err
}

// StationObservationLatest converts echo context to params.
func (w *ServerInterfaceWrapper) StationObservationLatest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId ObservationStationId

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params StationObservationLatestParams
	// ------------- Optional query parameter "require_qc" -------------

	err = runtime.BindQueryParameter("form", true, false, "require_qc", ctx.QueryParams(), &params.RequireQc)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter require_qc: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StationObservationLatest(ctx, stationId, params)
	return err
}

// StationObservationTime converts echo context to params.
func (w *ServerInterfaceWrapper) StationObservationTime(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId ObservationStationId

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	// ------------- Path parameter "time" -------------
	var time time.Time

	err = runtime.BindStyledParameterWithLocation("simple", false, "time", runtime.ParamLocationPath, ctx.Param("time"), &time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StationObservationTime(ctx, stationId, time)
	return err
}

// Tafs converts echo context to params.
func (w *ServerInterfaceWrapper) Tafs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId ObservationStationId

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Tafs(ctx, stationId)
	return err
}

// Taf converts echo context to params.
func (w *ServerInterfaceWrapper) Taf(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stationId" -------------
	var stationId ObservationStationId

	err = runtime.BindStyledParameterWithLocation("simple", false, "stationId", runtime.ParamLocationPath, ctx.Param("stationId"), &stationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stationId: %s", err))
	}

	// ------------- Path parameter "date" -------------
	var date Date

	err = runtime.BindStyledParameterWithLocation("simple", false, "date", runtime.ParamLocationPath, ctx.Param("date"), &date)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter date: %s", err))
	}

	// ------------- Path parameter "time" -------------
	var time Time

	err = runtime.BindStyledParameterWithLocation("simple", false, "time", runtime.ParamLocationPath, ctx.Param("time"), &time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Taf(ctx, stationId, date, time)
	return err
}

// SatelliteThumbnails converts echo context to params.
func (w *ServerInterfaceWrapper) SatelliteThumbnails(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "area" -------------
	var area string

	err = runtime.BindStyledParameterWithLocation("simple", false, "area", runtime.ParamLocationPath, ctx.Param("area"), &area)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter area: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SatelliteThumbnails(ctx, area)
	return err
}

// ZoneList converts echo context to params.
func (w *ServerInterfaceWrapper) ZoneList(ctx echo.Context) error {
	var err error

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ZoneListParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "area" -------------

	err = runtime.BindQueryParameter("form", false, false, "area", ctx.QueryParams(), &params.Area)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter area: %s", err))
	}

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", false, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", false, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "point" -------------

	err = runtime.BindQueryParameter("form", true, false, "point", ctx.QueryParams(), &params.Point)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter point: %s", err))
	}

	// ------------- Optional query parameter "include_geometry" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_geometry", ctx.QueryParams(), &params.IncludeGeometry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_geometry: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "effective" -------------

	err = runtime.BindQueryParameter("form", true, false, "effective", ctx.QueryParams(), &params.Effective)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter effective: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ZoneList(ctx, params)
	return err
}

// ZoneObs converts echo context to params.
func (w *ServerInterfaceWrapper) ZoneObs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "zoneId" -------------
	var zoneId NWSZoneId

	err = runtime.BindStyledParameterWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, ctx.Param("zoneId"), &zoneId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zoneId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ZoneObsParams
	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", ctx.QueryParams(), &params.Start)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start: %s", err))
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", ctx.QueryParams(), &params.End)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter end: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ZoneObs(ctx, zoneId, params)
	return err
}

// ZoneStations converts echo context to params.
func (w *ServerInterfaceWrapper) ZoneStations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "zoneId" -------------
	var zoneId NWSZoneId

	err = runtime.BindStyledParameterWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, ctx.Param("zoneId"), &zoneId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zoneId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ZoneStationsParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "cursor" -------------

	err = runtime.BindQueryParameter("form", true, false, "cursor", ctx.QueryParams(), &params.Cursor)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cursor: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ZoneStations(ctx, zoneId, params)
	return err
}

// ZoneListType converts echo context to params.
func (w *ServerInterfaceWrapper) ZoneListType(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "type" -------------
	var pType NWSZoneType

	err = runtime.BindStyledParameterWithLocation("simple", false, "type", runtime.ParamLocationPath, ctx.Param("type"), &pType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ZoneListTypeParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "area" -------------

	err = runtime.BindQueryParameter("form", false, false, "area", ctx.QueryParams(), &params.Area)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter area: %s", err))
	}

	// ------------- Optional query parameter "region" -------------

	err = runtime.BindQueryParameter("form", false, false, "region", ctx.QueryParams(), &params.Region)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter region: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", false, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "point" -------------

	err = runtime.BindQueryParameter("form", true, false, "point", ctx.QueryParams(), &params.Point)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter point: %s", err))
	}

	// ------------- Optional query parameter "include_geometry" -------------

	err = runtime.BindQueryParameter("form", true, false, "include_geometry", ctx.QueryParams(), &params.IncludeGeometry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include_geometry: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "effective" -------------

	err = runtime.BindQueryParameter("form", true, false, "effective", ctx.QueryParams(), &params.Effective)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter effective: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ZoneListType(ctx, pType, params)
	return err
}

// Zone converts echo context to params.
func (w *ServerInterfaceWrapper) Zone(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "type" -------------
	var pType NWSZoneType

	err = runtime.BindStyledParameterWithLocation("simple", false, "type", runtime.ParamLocationPath, ctx.Param("type"), &pType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Path parameter "zoneId" -------------
	var zoneId NWSZoneId

	err = runtime.BindStyledParameterWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, ctx.Param("zoneId"), &zoneId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zoneId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ZoneParams
	// ------------- Optional query parameter "effective" -------------

	err = runtime.BindQueryParameter("form", true, false, "effective", ctx.QueryParams(), &params.Effective)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter effective: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Zone(ctx, pType, zoneId, params)
	return err
}

// ZoneForecast converts echo context to params.
func (w *ServerInterfaceWrapper) ZoneForecast(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "type" -------------
	var pType string

	err = runtime.BindStyledParameterWithLocation("simple", false, "type", runtime.ParamLocationPath, ctx.Param("type"), &pType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Path parameter "zoneId" -------------
	var zoneId NWSZoneId

	err = runtime.BindStyledParameterWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, ctx.Param("zoneId"), &zoneId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter zoneId: %s", err))
	}

	ctx.Set(UserAgentScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ZoneForecast(ctx, pType, zoneId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/alerts", wrapper.AlertsQuery)
	router.GET(baseURL+"/alerts/active", wrapper.AlertsActive)
	router.GET(baseURL+"/alerts/active/area/:area", wrapper.AlertsActiveArea)
	router.GET(baseURL+"/alerts/active/count", wrapper.AlertsActiveCount)
	router.GET(baseURL+"/alerts/active/region/:region", wrapper.AlertsActiveRegion)
	router.GET(baseURL+"/alerts/active/zone/:zoneId", wrapper.AlertsActiveZone)
	router.GET(baseURL+"/alerts/types", wrapper.AlertsTypes)
	router.GET(baseURL+"/alerts/:id", wrapper.AlertsSingle)
	router.GET(baseURL+"/aviation/cwsus/:cwsuId", wrapper.Cwsu)
	router.GET(baseURL+"/aviation/cwsus/:cwsuId/cwas", wrapper.Cwas)
	router.GET(baseURL+"/aviation/cwsus/:cwsuId/cwas/:date/:sequence", wrapper.Cwa)
	router.GET(baseURL+"/aviation/sigmets", wrapper.SigmetQuery)
	router.GET(baseURL+"/aviation/sigmets/:atsu", wrapper.SigmetsByATSU)
	router.GET(baseURL+"/aviation/sigmets/:atsu/:date", wrapper.SigmetsByATSUByDate)
	router.GET(baseURL+"/aviation/sigmets/:atsu/:date/:time", wrapper.Sigmet)
	router.GET(baseURL+"/glossary", wrapper.Glossary)
	router.GET(baseURL+"/gridpoints/:wfo/:x,:y", wrapper.Gridpoint)
	router.GET(baseURL+"/gridpoints/:wfo/:x,:y/forecast", wrapper.GridpointForecast)
	router.GET(baseURL+"/gridpoints/:wfo/:x,:y/forecast/hourly", wrapper.GridpointForecastHourly)
	router.GET(baseURL+"/gridpoints/:wfo/:x,:y/stations", wrapper.GridpointStations)
	router.GET(baseURL+"/icons", wrapper.IconsSummary)
	router.GET(baseURL+"/icons/:set/:timeOfDay/:first", wrapper.Icons)
	router.GET(baseURL+"/icons/:set/:timeOfDay/:first/:second", wrapper.IconsDualCondition)
	router.GET(baseURL+"/offices/:officeId", wrapper.Office)
	router.GET(baseURL+"/offices/:officeId/headlines", wrapper.OfficeHeadlines)
	router.GET(baseURL+"/offices/:officeId/headlines/:headlineId", wrapper.OfficeHeadline)
	router.GET(baseURL+"/points/:point", wrapper.Point)
	router.GET(baseURL+"/points/:point/stations", wrapper.PointStations)
	router.GET(baseURL+"/products", wrapper.ProductsQuery)
	router.GET(baseURL+"/products/locations", wrapper.ProductLocations)
	router.GET(baseURL+"/products/locations/:locationId/types", wrapper.LocationProducts)
	router.GET(baseURL+"/products/types", wrapper.ProductTypes)
	router.GET(baseURL+"/products/types/:typeId", wrapper.ProductsType)
	router.GET(baseURL+"/products/types/:typeId/locations", wrapper.ProductsTypeLocations)
	router.GET(baseURL+"/products/types/:typeId/locations/:locationId", wrapper.ProductsTypeLocation)
	router.GET(baseURL+"/products/:productId", wrapper.Product)
	router.GET(baseURL+"/radar/profilers/:stationId", wrapper.RadarProfiler)
	router.GET(baseURL+"/radar/queues/:host", wrapper.RadarQueue)
	router.GET(baseURL+"/radar/servers", wrapper.RadarServers)
	router.GET(baseURL+"/radar/servers/:id", wrapper.RadarServer)
	router.GET(baseURL+"/radar/stations", wrapper.RadarStations)
	router.GET(baseURL+"/radar/stations/:stationId", wrapper.RadarStation)
	router.GET(baseURL+"/radar/stations/:stationId/alarms", wrapper.RadarStationAlarms)
	router.GET(baseURL+"/stations", wrapper.ObsStations)
	router.GET(baseURL+"/stations/:stationId", wrapper.ObsStation)
	router.GET(baseURL+"/stations/:stationId/observations", wrapper.StationObservationList)
	router.GET(baseURL+"/stations/:stationId/observations/latest", wrapper.StationObservationLatest)
	router.GET(baseURL+"/stations/:stationId/observations/:time", wrapper.StationObservationTime)
	router.GET(baseURL+"/stations/:stationId/tafs", wrapper.Tafs)
	router.GET(baseURL+"/stations/:stationId/tafs/:date/:time", wrapper.Taf)
	router.GET(baseURL+"/thumbnails/satellite/:area", wrapper.SatelliteThumbnails)
	router.GET(baseURL+"/zones", wrapper.ZoneList)
	router.GET(baseURL+"/zones/forecast/:zoneId/observations", wrapper.ZoneObs)
	router.GET(baseURL+"/zones/forecast/:zoneId/stations", wrapper.ZoneStations)
	router.GET(baseURL+"/zones/:type", wrapper.ZoneListType)
	router.GET(baseURL+"/zones/:type/:zoneId", wrapper.Zone)
	router.GET(baseURL+"/zones/:type/:zoneId/forecast", wrapper.ZoneForecast)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
